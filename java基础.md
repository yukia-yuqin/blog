# java基础

## java语言和c/c++有什么异同点

    相同点: java和C++都是面向对象语言,都使用了面向对象思想(封装,继承,多态)

    不同点:1 java为解释性语言, 经过java编译器编译成字节码, 然后由jvm解释执行. 2不支持多重继承 3 支持自动垃圾回收 4 不支持预处理,但提供的import机制和预处理功能类似 5 平台无关性, int类型总是占据32位 6 java提供对注释文档的内建支持 7 java包含了一些标准库,例如提供用于访问数据库的jdbc库, 用于实现分布式对象的rmi等标准库.

## java中的作用域有哪些?

    java变量类型主要有三种: 成员变量\静态变量和局部变量. protected表明该成员变量或方法对自己及子类可见. default表明该成员变量或方法只有自己和与其位于同一包内的类可见.若父类与子类位于同一个包内, 则子类对父类的default成员变量或方法具有访问权限, 否则没有. 这些修饰符只能用来修饰成员变量, 不能修饰局部变量. private 和 protected 不能用来修饰类, 只有public abstract或final能用来修饰类.

## 什么是构造函数

    构造函数是一种特殊的函数, 用来在对象实例化时初始化对象的成员变量. 在java语言中, 构造函数具有以下特点: 1 构造函数必须与类的名字相同, 且不能有返回值, 2 每个类可以有多个构造函数 3 构造函数可以有多个参数 4 构造函数总是伴随着new操作一起调用,且不能由程序的编写者直接调用, 必须要由系统调用.

## 普通方法是否可以与构造函数有相同的方法名?

    可以

## 为什么java中有些接口没有任何方法?

    没有任何方法声明的接口被叫做标识接口, 标识接口对实现他的 类没有任何的语义上的要求，他仅仅充当一个标识的作用，用来表明它的类属于一个特定的类型.  java类库中已存在的标识接口clonable和serializable等, 在使用时会经常用instanceof来判断实例对象的类型是否实现了一个给定的标识接口.

## java中的clone方法有什么用?

    实现克隆的类，首先需要继承cloneable接口，实际上是一个标识接口，没有任何接口方法. 在类中重写Object类中的clone方法.  在Clone方法中调用super.clone无论cloud类的继承结构是什么super.clone会直接或间接的调用object类的Clone方法，把浅复制的引用指向原型对象新的克隆体.

    在对象调用clone方法完成复制后，需要手动对对象中的非基本类型的属性也调用clone方法完成深复制.

## 反射机制有什么作用?

    反射机制是java语言中一个非常重要的特性. 它允许程序在运行时进行自我检查，同时也允许对其内部的成员进行操作。这个程序在C++的语言中根本就没有提供这样的特性. 由于反射机制能够实现在运行时对类进行装载. 因此能够增加程序的灵活性，但是不恰当的使用反射机制也会严重影响系统性能。

## java创建对象的方式有几种?

    通过new语句实例化一个对象，第二通过反射机制创建对象. 第三通过clone方法创建一个对象，第四通过反序列化的方式创建对象.

## 面相对象有哪些特征？

    面向对象的主要特征，包括抽象继承封装和多态. 抽象就是忽略一个主题中与当前目标无关的那些方面, 以便更充分地注意与当前目标有关的方面. 抽象并不打算 了解全部问题，而只是选择其中的一部分暂时不用关注细节. 抽象包括两个方面，一是过程抽象, 二是数据抽象.

    继承是一种联结类的层次模型.

    封装是指将客观事物抽象成类.

    多态

## 多态的实现机制是什么?

    方法的重载重载是指同一个类中有多个同名的方法，但这些方法有着不同的参数，因此在编译时就可以确定到底使用哪个方法，他是一种编译时的多态.

    方法的覆盖. 子类可以覆盖父类的方法，因此同样的方法会在父类与子类中有着不同的表现形式.

## 重载和覆盖有什么区别?

    重载是通过不同的方法参数来区分的, 例如不同的参数个数\不同的参数类型或不同的参数顺序.

    不能通过方法的访问权限\返回值类型和抛出的异常类型来进行重载.

    如果资类方法的访问权限为private那么就不能在派生类对其重载。如果派生那也定义一个同名的函数，这只是一个新的方法，不会达到重载的效果。

## 抽象类与接口有什么异同？

    相同点: 都不能被实例化.

   不同点: 1 接口强调特定功能的实现,has-a 抽象强调所属关系, is-a 2 接口中定义的成员变量默认为public static final, 必须赋初值, 其所有成员方法都是public abstract的.

## java的内部类有哪些?

    静态内部类: 不能与外部类有相同的名字, 不能访问外部类的普通成员变量, 只能访问外部类中的静态变量和静态方法.

    成员内部类: 成员内部类不可以定义静态成员变量或方法; 可以引用外部类的成员变量和方法; 只有当外部类被实例化后, 成员内部类才能被实例化.

    局部内部类: 局部内部类像局部变量一样,不能被public\protected\private\static修饰, 只能访问方法中定义为final类型的局部变量.(why?)

    匿名内部类: 匿名内部类不能有构造函数; 匿名内部类不能定义静态成员\方法\类; 匿名内部类不能使用public\protected\private\static关键字; 只能创建匿名内部类的一个实例; 一个匿名内部类一定是在new关键字后面, 这个匿名内部类必须聚成一个父类或实现一个接口.

## 如何获取父类的类名?

    反射.this.getClass().getSuperClass().getName(). 因为调用super.getClass().getName()和this.getClass().getName()都是调用Object类的getClass方法, 获取此Object的运行时类.

## this和super有什么区别?

    this用来区分对象的成员变量和方法的形参. super关键字可以用来访问父类的方法和成员变量.

## final关键字?

    final用于声明属性\方法\参数和类, 分别表示属性不可变\方法不可覆盖\参数不可修改和类不可被继承.

    final属性, 引用不可变

   final类: final类的所有方法不能被重写, final类的成员变量可以变.

## static关键字作用?

    1 为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关;   2 实现某方法或属性与类而不是对象关联在一起.

## switch关键字?

    内部选择的值只能是一个枚举常量或一个整数表达式或字符串. 由于byte short char都能隐式转为int, 因此这些类型和她们的包装类型都可以作为switch的表达式.

## volatile关键字?

    volatile定义的变量, 系统每次用到它都是直接从对应内存中提取, 而不会利用缓存. 在使用了volatile修饰成员变量之后, 所有线程在任何时候锁看到的变量的值都是相同的.

## null 是什么?

    null 不是一个合法的object实例. 所以编译器没有为其分配内存. null是将引用变量的值全部置为0.

## round ceil floor

    round四舍五入  ceil向上取整 floor向下取整

## ==和equals?

    == 比较基本类型 或 两个变量是否指向同一个对象

    equals在没有覆盖Object的方法情况下, equals和==一样比较的是引用. equals可以被覆盖, 例如string的equals方法用于比较两个独立对象的内容是否相同.

    hashcode返回对象在内存中地址转换成的一个int值. 如果equals方法返回true, 那么hashcode方法必须产生同样的结果. 如果equals方法返回false, 那么hashcode方法返回值可能相等, 可能不等.

## string stringbuffer stringbuilder

    stringbuilder 线程不安全, 效率最高

    stringbuffer 线程安全, 效率较低

    string 线程安全, 效率最低.

## 数组初始化

    int [] a = new int[5]  或 int[]a = {1,2,3,4,5}

## length属性和length()方法有什么区别?

    length属性针对数组, length()方法针对字符串.size()针对集合.

## finally代码块什么时候被执行?

    return之前执行. finally中的return会覆盖别处的return语句.

## java异常?

    throwable是所有异常的父类. error和exception.

## io流的实现机制是什么?

    字节流(以字节8bit为单位, inputStream outputStream) 字符流(以字符16bit为单位, reader writer)

    字节流在处理输入输出没有用到缓存, 字符流用到了缓存.

    io类在设计时采用了装饰着设计模式.

## NIO是什么?

    非阻塞io.**NIO通过selector \ channel 和 buffer**实现非阻塞的io操作, NIO主要采用了reactor设计模式. selector实现了用一个线程来管理多个通道(channel的io事件: connect, read, write均注册给selector), 类似一个观察者, selector对所有注册的channel进行轮询访问, 一旦轮询到一个channel有注册的事件发生, 就通过传回selection-key的方式来通知开发人员对channel进行数据的读写操作.

    优势: 轮询在处理多线程请求时 需要上下文的切换，而采用多线程的实现方式在线程之间切换时，需要上下文的切换，同时需要进行压栈与弹栈的操作，因此NIO有较高的执行效率.

    buffer用来保存channel收到的数据或发送的数据.

## 序列化

    特点: 1 如果一个类能被序列化, 那么它的子类也能够被序列化. 2 由于static代表类的成员, transient (当对象存储时, 它的值不需要维持)代表对象的临时数据. 因此，这两种类型的数据成员是不能够被序列化的.

## 类的加载

    jvm会将编译生成的.class文件按照需求和一定的规则加载到内存中, 并组织成为一个完整的java应用程序, 加载是由classloader和它的子类实现的.

    类的加载方式: 隐式加载: new的时候加载 显示加载: class.forname.

    程序启动时只会把需要的类加载到jvm中, 其他的类只有被使用的时候会被加载.

    垃圾回收器使用有向图记录和管理堆内存中的所有对象, 通过这个有向图可以识别哪些对象是可达的.

## 垃圾回收算法?

    引用计数(无法解决循环依赖)\追踪回收(有向图)\压缩回收(性能开销大)\复制回收(分两块, 内存开销大, 调整过程中需要中断当前程序)\按代回收

   system.gc() 方法的执行会停止所有响应, 去检查内存中是否有可回收的对象, 不推荐使用.

## java内存泄露有哪些情况?

    1) 静态集合类, hashmap, 它们的生命周期与程序一致, 那么容器中的对象在程序结束之前不能释放. 2 各种连接 3 监听器 4 不合理的作用域 5 单例模式
