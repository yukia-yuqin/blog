---
layout: post
title: java
tags: java
categories: java
---

> effective java 

 

学习别人的：

[https://github.com/mengdd/Effective-Java-Reading-Notes/blob/3rd-edition/2%20Creating%20and%20Destroying%20Objects.md](https://github.com/mengdd/Effective-Java-Reading-Notes/blob/3rd-edition/2 Creating and Destroying Objects.md)

### **第2章 阐述何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清除动作。**

## 第1条 考虑用静态工厂方法代替构造器

- 静态工厂方法**有名称**
- **不必在每次调用它们的时候都创建一个新对象.**
- **可以返回原类型的子类型对象.**静态工厂方法还有一个好处，就是可以返回子类型，比如我们有一个Car类，其中有一个关键的参数叫做price，我希望price>30万的返回豪车子类，price<30万的返回买菜车子类

## 第2条 遇到多个构造器参数时要考虑用Builder

- 因为构造过程被分到了几次调用中，所以在构造过程中可能会处于不一致的状态。类无法仅仅通过检验构造器参数的有效性来保证一致性。[注]对于这句话，我个人的理解如下.比如上面的用户类，我们规定如果职位为Java开发工程师，则性别一定是男性。但是由于`setter`方法是分成两部进行设置值，而且设置值的顺序也是不一致的，所以就无法使两个参数同时满足上面的要求。

- Builder模式的优势: 可读性增强; 可以有多个可变参数; 易于做参数检查和构造约束检查; 比JavaBeans更加安全; 灵活性: 可以利用单个builder构建多个对象, 可以自动填充某些域, 比如自增序列号.

  Builder模式的不足: 为了创建对象必须先创建Builder, 在某些十分注重性能的情况下, 可能就成了问题; Builder模式较冗长, 因此只有参数很多时才使用。

## 第3条 用私有构造器或者枚举类型强化Singleton属性

- 从Java 1.5起, **可以使用枚举来实现单例**: 只需要编写一个包含单个元素的枚举类型. 这种方法无偿地提供了序列化机制, 绝对防止多次实例化.
### 第6条 避免创建不必要的对象
- String s = new String("bikini"); // Don't do this
- 这段程勋的答案是正确的，但是比实际情况更慢一些，只因为打错了一个字符，**变量sum被声明称Long而不是long，以为着程序构造了大约2^31个多余的Long实例。**将sum上午声明从Long变成long，在我机器上运行的时间从8.952秒减少到了0.821秒。结论很明显，要优先考虑基本类型而不是装箱基本类型，要当心无意识地装箱。（4）对象重用在数据库连接池中非常有意义。
### JSON是怎么做的？fastjson为什么有很多漏洞？
- AutoType 何方神圣？fastjson的主要功能就是将Java Bean序列化成JSON字符串，这样得到字符串之后就可以通过数据库等方式进行持久化了。但是，fastjson在序列化以及反序列化的过程中并没有使用Java自带的序列化机制，而是自定义了一套机制。其实，对于JSON框架来说，想要把一个Java对象转换成字符串，可以有两种选择：1、基于属性2、基于setter/getter
- 而我们所常用的JSON序列化框架中，FastJson和jackson在把对象序列化成json字符串的时候，是通过遍历出该类中的所有getter方法进行的。Gson并不是这么做的，他是通过反射遍历该类中的所有属性，并把其值序列化成json。
- 当一个类中包含了一个接口（或抽象类）的时候，在使用fastjson进行序列化的时候，会将子类型抹去，只保留接口（抽象类）的类型，使得反序列化时无法拿到原始类型。
- 在之后的几个版本中，黑客的主要的攻击方式就是绕过黑名单了，而fastjson也在不断的完善自己的黑名单。
- 因为fastjson自己定义了序列化工具类，并且使用asm技术避免反射、使用缓存、并且做了很多算法优化等方式，大大提升了序列化及反序列化的效率。

-



自己总结：

### 字符串

- m.put ( new PhoneNumbe（707，867，5309），“jenny”），此时是根据hash值来进行存储到散列桶的，因此需要重写hashCode的方法。
- 在实际应用中， toString 方法应该返回对象中包含的所有值得关注的信息，、
- 事实上，实现Cloneable 接口的类是为了提供一个功能适当的公有的cl 。ne 方法。为了达到这个目的，类及其所有超类都必须遵守一个相当复杂的、
  不可实施的，并且基本上没有文档说明的协议。由此得到一种语言之外的（ extralinguistic)机制：它无须调用构造器就可以创建对象。
- 因为Java 支持协变返回类型（ covariant return type ） 。换句话说，目前覆盖方法的返回类型可以是被覆盖方法的返回类型的子类了。、
- 这是个根本的问题： 就像序列化一样， Cloneable 架构与引用可变对象的final 域的正常用法是不相兼容的，

### 类和接口

- 为了测试而将一个公有类的私有成员变成包级私有的，这还可以接受， 但是要将访问级别提高到超过它，这就无法接受了。 
- 不可变对象
  - 没有任何线程会注 意到其他线程对于不可变对象的影响。 所以， 不可变对象可以被自由地共享。 
  - 在设计新的类时，选择用静态工厂代替公有的构造器可以让你以后有添加缓存的灵活性，而不必影响客户端。 
  - 不仅可以共享不可变对象，甚至也可以共享它们的内部信息。 
  - 不可变的类变成 final 的另一种办法就是，让类的所有构造器都变成私有的或者包级私 有的，并添加公有的静态工厂（ static factory）来代替公有的构造器
-  好的 API 文档应该描述一个给定的方法做了什么工作，而不是描述它是如何做到的。

### 泛型

- 泛型有子类型化（ subtyping ）的规则，List<String ＞是原生态类型List 的一个子类型，而不是参数化类型List<Object>的子类型（详见第28 条）
- 如果要使用泛型，但不确定或者不关心实际的类型参数，就可以用一个问号代替。例如，泛型Set<E ＞的无限制通配符类型为Set <?>（读作“某个类型的集合”） 。
- 无限制通配类型Set ＜？＞和原生态类型Set 之间有什么区别呢？这个问号真正起到作用了吗？这一点不需要赘述，但通配符类型是安全的，原生态类型则不安全。由于可以将任何元素放进使用原生态类型的集合中，因此很容易破坏该集合的类型约束条件（如之前范例中所示的u 口saf eAdd 方法）；但不能将任何元素（除了null 之外）放到c。llection < ?>中。如果尝试这么做，将会产生一条像这样的编译时错误消息：error: incompatibl e types: String can not be converted to CAP
- 必须在类文字（ class l i te ra l ） 中使用原生态类型。规范不允许使用参数化类型（虽然允许数组类型和基本类型）［ JLS, 15.8.2 ］ 。换句话说， List.class 、String.class 和int.class 都合法，但是List<String .class 和List<?>.class 则不合法。
- 由于泛型信息可以在运行时被擦除，因此在参数化类型而非无限制通配柯：类型上使用instanceof 操作符是非法的
- II Legitima t e use of raw type - instanceof operator if (o i nstanceof Set) { II Raw t ype Set<?> s = (Set<?>) o; I I Wi l dca 「d type 注意，一旦确定这个o 是个Set ，就必须将它转换成通配符类型Set ＜？＞，而不是转 换成原生态类型Set 。这是个受检的（ checked ）转换，因此不会导致编译时警告。
- 原生态类型只是为了与引人泛型之前的遗留代码进行兼容和互用而提供的。让我们做个快速的回顾：Set<Object ＞是个参数化类型，表示可以包含任何对象类型的一个集合； Set ＜？＞则是一个通配符类型，表示只能包含某种未知对象类型的一个集合； Set 是一个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。
- 如果无法消除警告，同时可以证明引起警告的代码是类型安全的，（只有在这种情况下）才可以用一个＠S uppre ss Warnings ( “ unchecked“ ）注解来禁止这条警告。
-   这其中无论哪一种方法，都不能将String 放进Long 容器中，但是利用数组，你会在运行时才发现所犯的错误；而利用列表，则可以在编译时就发现错误。我们当然希望在编译时就发现错误。

### 方法

- 说概要描述是文档注释中的第一个句子（ sentence ），这似乎有点误导人。规范指出，概要描述很少是个完整的句子。对于方法和构造器而言，概要描述应该是个完整的动词短语（包含任何对象），它描述了该方法所执行的动作。对于类、接口和域，概要描述应该是一个名词短语，它描述了该类或者接口的实例，或者域本身所代表的事物。
- API 有两个特征在文档中经常被忽视，即线程安全性和可序列化性。类或者静态方法是否线程安全，应该在文档中对它的线程安全级别进行说明。
### 通用编程

- 将局部变量的作用域最小化。要使局部变量的作用域最小化，最有力的方法就是在第一次要使用它的地方进行声明。
- 当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱。
- 基本类型要优先于装箱基本类型。基本类型更加简单，也更加快速。如果必须使用装箱基本类型，要特别小心！ 自动装箱减少了使用装箱基本类型的烦琐性，但是并没有减少它的风险。
- 字符串不适合代替其他的值类型。
- 口损失了编译时类型检查的优势，包括异常检查。如果程序企图用反射方式调用不存在的或者不可访问的方法在运行时它将会失败，除非采取了特别的预防措施。
- Java Native Interface （刑I) 允许Java 应用程序调用本地方法（ native method ），所谓本地方法是指用本地编程语言（比如C 或者C＋＋）来编写的方法。它们提供了“访问特定于平台的机制”的能力，比如l访问注册表（ registry ）
- 当你确定类是私有的或包私有的 并且equals方法不被调用时 无需覆盖equals。

### 相关知识
### 简单工厂（静态工厂）

**定义**：由一个工厂对象决定创建出哪一种产品类的实例

**类型**：创建型，不属于GOF23种设计模式

**适用场景**：

- 工厂类负责创建的对象比较少
- 客户端（应用层）只知道传入工厂类的参数，对于如何创建对象（逻辑）并不关心

**优点**：

- 只需要传入一个正确的参数，就可以获取你所需要的对象而不需要知道其创建的细节

**缺点**：

- 工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背了开闭原则