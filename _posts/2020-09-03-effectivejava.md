---
layout: post
title: java
tags: java
categories: java
---

> effective java 

 

### 字符串

- m.put ( new PhoneNumbe（707，867，5309），“jenny”），此时是根据hash值来进行存储到散列桶的，因此需要重写hashCode的方法。
- 在实际应用中， toString 方法应该返回对象中包含的所有值得关注的信息，、
- 事实上，实现Cloneable 接口的类是为了提供一个功能适当的公有的cl 。ne 方法。为了达到这个目的，类及其所有超类都必须遵守一个相当复杂的、
  不可实施的，并且基本上没有文档说明的协议。由此得到一种语言之外的（ extralinguistic)机制：它无须调用构造器就可以创建对象。
- 因为Java 支持协变返回类型（ covariant return type ） 。换句话说，目前覆盖方法的返回类型可以是被覆盖方法的返回类型的子类了。、
- 这是个根本的问题： 就像序列化一样， Cloneable 架构与引用可变对象的final 域的正常用法是不相兼容的，

### 类和接口

- 为了测试而将一个公有类的私有成员变成包级私有的，这还可以接受， 但是要将访问级别提高到超过它，这就无法接受了。 
- 不可变对象
  - 没有任何线程会注 意到其他线程对于不可变对象的影响。 所以， 不可变对象可以被自由地共享。 
  - 在设计新的类时，选择用静态工厂代替公有的构造器可以让你以后有添加缓存的灵活性，而不必影响客户端。 
  - 不仅可以共享不可变对象，甚至也可以共享它们的内部信息。 
  - 不可变的类变成 final 的另一种办法就是，让类的所有构造器都变成私有的或者包级私 有的，并添加公有的静态工厂（ static factory）来代替公有的构造器
-  好的 API 文档应该描述一个给定的方法做了什么工作，而不是描述它是如何做到的。

### 泛型

- 泛型有子类型化（ subtyping ）的规则，List<String ＞是原生态类型List 的一个子类型，而不是参数化类型List<Object>的子类型（详见第28 条）

- 如果要使用泛型，但不确定或者不关心实际的类型参数，就可以用一个问号代替。例如，泛型Set<E ＞的无限制通配符类型为Set <?>（读作“某个类型的集合”） 。

- 无限制通配类型Set ＜？＞和原生态类型Set 之间有什么区别呢？这个问号真正起到作用了吗？这一点不需要赘述，但通配符类型是安全的，原生态类型则不安全。由于可以将任何元素放进使用原生态类型的集合中，因此很容易破坏该集合的类型约束条件（如之前范例中所示的u 口saf eAdd 方法）；但不能将任何元素（除了null 之外）放到c。llection < ?>中。如果尝试这么做，将会产生一条像这样的编译时错误消息：error: incompatibl e types: String can not be converted to CAP

- 必须在类文字（ class l i te ra l ） 中使用原生态类型。规范不允许使用参数化类型（虽然允许数组类型和基本类型）［ JLS, 15.8.2 ］ 。换句话说， List.class 、String.class 和int.class 都合法，但是List<String .class 和List<?>.class 则不合法。

- 由于泛型信息可以在运行时被擦除，因此在参数化类型而非无限制通配柯：类型上使用instanceof 操作符是非法的

- II Legitima t e use of raw type - instanceof operator if (o i nstanceof Set) { II Raw t ype Set<?> s = (Set<?>) o; I I Wi l dca 「d type 注意，一旦确定这个o 是个Set ，就必须将它转换成通配符类型Set ＜？＞，而不是转 换成原生态类型Set 。这是个受检的（ checked ）转换，因此不会导致编译时警告。

- 原生态类型只是为了与引人泛型之前的遗留代码进行兼容和互用而提供的。让我们做个快速的回顾：Set<Object ＞是个参数化类型，表示可以包含任何对象类型的一个集合； Set ＜？＞则是一个通配符类型，表示只能包含某种未知对象类型的一个集合； Set 是一个原生态类型，它脱离了泛型系统。前两种是安全的，最后一种不安全。

- 如果无法消除警告，同时可以证明引起警告的代码是类型安全的，（只有在这种情况下）才可以用一个＠S uppre ss Warnings ( “ unchecked " ）注解来禁止这条警告。

- 这其中无论哪一种方法，都不能将String 放进Long 容器中，但是利用数组，你会在运行时才发现所犯的错误；而利用列表，则可以在编译时就发现错误。我们当然希望在编译时就发现错误。

- 数组是具体化的（ reified) [ JLS , 4.7 ］ 。因此数组会在运行时知道和强化它们的元素类型。如上所述，如果企图将String 保存到Lo呵数组中，就会得到一个ArrayStoreExcept 工on 异常。相比之下，泛型则是通过擦除( erasure ) [ JLS, 4.6 ］ 来实现的。这意味着，泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。擦除就是使泛型可以与没有使用泛型的代码随意进行互用（详见第26 条），以确保在Java 5 中平滑过渡到泛型。

- 不可具体化的（ non-reifiable ）类型是指其运行时表示法包含的信息比它的编译时表示法包含的信息更少的类型。唯一可具体化的( reifiable ）参数化类型是无限制的通配符类型，如List ＜？＞和Map<?,?>

- Favorites 实例是类型安全（ typ巳safe ）的： 当你向它请求String 的时候， 它从来不会返回一个Integer 给你。同时它也是异构的（ heterogen eou s ） ： 不像普通的映射，它的所有键都是不同类型的。因此，我们将Favorites 称作类型安全的异构容器（ typ esafe heterogeneous contain巳r ） 。

- cast 方法是Jav a 的转换操作符的动态模拟。它只检验它的参数是否为Class 对象所表示的类型的实例。如果是，就返回参数；否则就抛出ClassCastException 异.

  ### 枚举

- 枚举天生就是不可变的，因此所有的域都应该为final 的（详见第17 条） 。它们可以是公有的，但最好将它们做成私有的，并提供公有的访问方法（详见第16 条） 。

- 于是每个枚举常量都带有一组隐藏的行为，这使得枚举类型的类或者所在的包能够运作得很好，像其他的类一样，除非要将枚举方法导出至它的客户端，否则都应该声明为私有的，或者声明为包级私有的

- 因为枚举类型中的抽象方法必须被它的所有常量中的具体方法所覆盖。

- 我们真正想要的就是每当添加一个枚举常量时，就强和！选择一种加班报酬策略。幸运的是，有一种很好的方法可以实现这一点。这种想法就是将加班工资计算移到一个私有的嵌套枚举中，将这个策略枚举（ strategy enum ）的实例传到Payroll Day 枚举的构造器中。之后Payroll Day 枚举将加班工资计算委托给策略枚举， Payroll Day 中就不需要switch语句或者特定于常量的方法实现了。

- P 「ivate static <T extends Enum<T> & Operation> void test(Class<T> opEnumType , do ubl e x, double Y] opEηum Type 参数中公认很复杂的声明（<T extendsEnum<T>& Operation> Class<T ＞）确保了Class 对象既表示枚举又表示Operation的子类型，这正是遍历元素和执行与每个元素相关联的操作时所需要的。

  ### lambda 和 stream

- 基础接口作用于对象引用类型。Operator 接口代表其结果与参数类型一致的函数。Predicate 接口代表带有一个参数并返回一个boolean 的函数。Fun ct 工on 接口代表其参数与返回的类型不一致的函数。Suppl 工er 接口代表没有参数并且返回（或“提供”）一个值的函数。最后， Consumer 代表的是带有一个函数但不返回任何值的函数，相当于消费掉了其参数。

### 方法

- 采用了新的构造器和新的访问方法之后， **Period 真正是不可变的了**。不管程序员是多么恶意，或者多么不合格，都绝对不会违反“周期的起始时间不能晚于结束时间”这个约束条件。确实如此，**因为除了Period 类自身之外，其他任何类都无法访问Period 实例中的任何一个可变域。**这些域被真正封装在对象的内部。
- 