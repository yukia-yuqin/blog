---
layout: post
title: 设计模式
tags: 设计模式 
categories: 设计模式
---
since 2020-02-27，共150节。750分钟，12.5小时。预期：一个月学完。学完记得给自己出一张卷子，根据问题画出类图，根据类图写出代码！（02-27=P1-P7，2-28日=P8-P13，3-1=P14-P24一半，3-3=P24-P28，3-4=P29-P38，3-9=P39-p48，3-15,16=p49-p64，17=P65-70，4月-9日=P71-76，4月10日=P77-P112）
尚硅谷Java设计模式，韩顺平图解java设计模式【Bilibili】 <br>
学习过程，以看和记为主！运行什么的，有条件再说。
<br>

- 前言
    - 设计模式（design pattern）是对软件设计中普遍存在（反复出现） 的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人 在1990年代从建筑设计领域引入到计算机科学的  
    - 面试都会问你在实际项目中使用过什么 设计模式，怎样使用的，解决了什么问题。 
    - 设计模式在软件中哪里？
        - 面向对象(oo)=>功能模块[设计模式+算法(数据结构)]=>框架[使用到多种设计模式]=>架构 [服务器集群] 
    - 依赖就是使用的意思。
    -  接口隔离原则(Interface Segregation Principle)：客户端不应该依赖它不需要的接 口，即一个类对另一个类的依赖 应该建立在最小的接口上
    - 单一职责原则：降低类的复杂度，一个类只负责一项职责。 
    - 依赖倒转原则：依赖倒转原则(Dependence Inversion Principle)是指： 1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象 2) 抽象不应该依赖细节，细节应该依赖抽象 3) 依赖倒转(倒置)的中心思想是面向接口编程 //俄罗斯套娃。
        - 接口传递 应用案例代码 + 构造方法传递 应用案例代码 + setter方式传递 
    -  里氏替换原则
        -  在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法 4) 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可 以通过聚合，组合，依赖 来解决问题。
    - 开闭原则
        - 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用 方)。用抽象构建框架，用实现扩展细节。 
    - 迪米特原则
        - 我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友。而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量 的形式出现在类的内部。
        - 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的 越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内 部。对外除了提供的public 方法，不对外泄露任何信息。迪米特法则还有个更简单的定义：只与直接的朋友通信
    
- UML类图
    - URL类图标志：
        - 虚线        - 依赖，将A当作B方法中的参数。依赖关系：1）类中用到了对方 2) 如果是类的成员属性 3) 如果是方法的返回类型 4) 是方法接收的参数类型 5) 方法中使用到
        - 实线        - 关联，依赖的特例。使用某个成员。人和身份证。
        - 三角实线     - 泛化-继承-类。A继承B类
        - 三角虚线     - 实现-接口。A实现B类
        - 空心菱形实线 - 聚合，A类是B类的属性；整体与部分可以分开。关联关系的特例。整体和部分的关系。电脑和鼠标。
        - 黑色菱形实线 - 组合，new一个A的类出来；整体与部分不可以分开。同生共死关系。头和人的关系。
    
- 创建型模式（5）
    - 单例模式（10节课）
        - 饿汉式（静态常量）应用实例 
            - 步骤如下： 1) 构造器私有化 (防止 new ) 2) 类的内部创建对象 3) 向外暴露一个静态的公共方法。getInstance 4) 代码实现
            - 优缺点说明： 1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同 步问题。 2) 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始 至终从未使用过这个实例，则会造成内存的浪费3) 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载 时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载 的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类 装载，这时候初始化instance就没有达到lazy loading的效果
        - 饿汉式（静态代码块）
            - 优缺点说明：1) 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块 中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优 缺点和上面是一样的。 2) 结论：这种单例模式可用，但是可能造成内存浪费
        - 懒汉式(线程不安全)
            - 优缺点说明：1) 起到了Lazy Loading的效果，但是只能在单线程下使用。 2) 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及 往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以 在多线程环境下不可使用这种方式 3) 结论：在实际开发中，不要使用这种方式.
        - 懒汉式(线程安全，同步方法)
            - 优缺点说明：1) 解决了线程不安全问题 2) 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行 同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例， 直接return就行了。方法进行同步效率太低 3) 结论：在实际开发中，不推荐使用这种方式
        - 懒汉式(线程不安全，同步代码块)
            - 优缺点说明：1) 这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低， 改为同步产生实例化的的代码块 2) 但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一 致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行， 另一个线程也通过了这个判断语句，这时便会产生多个实例 3) 结论：在实际开发中，不能使用这种方式
        - 双重检查应用实例（线程安全，懒加载，推荐使用）
            - 优缺点说明：1) Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两 次if (singleton == null)检查，这样就可以保证线程安全了。 2) 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)， 直接return实例化对象，也避免的反复进行方法同步. 3) 线程安全；延迟加载；效率较高 4) 结论：在实际开发中，推荐使用这种单例设计模式。同步的效率比较低。
        -  静态内部类（线程安全，懒加载，推荐使用！简单方便）
            - 类装载的时候，静态内部类不会被装载。在用getInstance的时候可以直接装载，且线程安全。
            -优缺点说明：1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。 2) 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化 时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的 实例化。 3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们 保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 4) 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高 5) 结论：推荐使用.
        - 枚举（这个开始不懂）
            - 优缺点说明：1) 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而 且还能防止反序列化重新创建新的对象。 2) 这种方式是Effective Java作者Josh Bloch 提倡的方式 3) 结论：推荐使用
        - 单例模式在JDK 应用的源码分析
            - 1) 我们JDK中，java.lang.Runtime就是经典的单例模式(饿汉式) 
        - 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或 耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数 据库或文件的对象(比如数据源、session工厂等)
    - 抽象工厂模式
        - 简单工厂模式
            - 传统的方式的优缺点1) 优点是比较好理解，简单易操作。 2) 缺点是违反了设计模式的ocp原则，即对扩展开放，对修改关闭。即当我们给类增 加新功能的时候，尽量不修改代码，或者尽可能少修改代码. 3) 比如我们这时要新增加一个Pizza的种类(Pepper披萨)改进的思路分析分析：修改代码可以接受，但是如果我们在其它的地方也有创建Pizza的代码，就意味 着，也需要修改，而创建Pizza的代码，往往有多处。 思路：把创建Pizza对象封装到一个类中，这样我们有新的Pizza种类时，只需要修改该 类就可，其它有创建到Pizza对象的代码就不需要修改了.-> 简单工厂模式//很多地方都要修改。
            - 简单工厂模式:1) 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一 个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族 中最简单实用的模式 2) 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行 为(代码) 3) 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会 使用到工厂模式.
    - 工厂方法模式
        - 工厂方法模式介绍。工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点 餐子类中具体实现。工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方 法模式将对象的实例化推迟到子类
        - 抽象工厂模式
            - 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需 指明具体的类 2) 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。 3) 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。 4) 将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以 根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇， 更利于代码的维护和扩展。 
        - JDK中Calendar使用到了简单工厂模式，直接用getInstance调用就是一个静态方法。先获取一个provider，根据不同的情况返回不同的calendar的实例。
    - 原型模式
        - 例子：克隆羊
        - java默认浅拷贝。克隆的对象没有被复制，只是引用指向原始对象的内存空间。浅拷贝。
        - 直接override clone这个方法就可以。implements cloneable.
        - spring 框架里面getBean就是用的原型模式
        - 深拷贝实现方式:重写clone方法；对象序列化。clone方法会对字符串和基本数据类型进行复制。
    - 建造者模式 （模板方法，生成器模式）【没有讲好】
        - 盖房子需求，打桩、砌墙、封顶
        - 传统方法：抽象类，抽象方法。
        - 产品和产品过程解耦
        - 建造者模式的四个角色:产品角色、抽象建造者、具体建造者、指挥者
        - “如果产品之间 的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。”
- 结构型模式 （7）
    - 适配器模式(adapter, wrapper)
        - 目的是兼容。
        - 方法适配器，接口适配器，类适配器
        - 类适配器：
        - 对象适配器
            - 对象适配器模式是适配器模式常用的一种。
            - private Voltage220 voltage220; //持有Voltage220对象,不是继承了 
        - 适配器模式(Default Adapter Pattern)或缺省适配器模式。当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接 口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆 盖父类的某些方法来实现需求。适用于一个接口不想使用其所有的方法的情况。
    - 桥接模式
        - 比较简单
    - 装饰模式
        - 类似打包快递，陶瓷、衣服是被装饰者，报纸填充、塑料泡沫是装饰者。
        - 装饰者抽象器和被装饰者共同继承一个类，一个类继承A类，同时输入A类的对象，则有可能是装饰模式。
        - 例如JDK中的InputStream类。
    - 组合模式
        - 学校院系展示要求（部分和整体的关系），根据树状结构组合对象
        - 聚合一般用一个list来组织即可。
        - JDK中HashMap用到了这个模式。Map类似Component，HashMap是一个中间的构建(composite)，实现了相关方法put, putall；Node是HashMap的静态内部类。
    - 外观模式
        - 家庭影院。
        - 让系统更有层次感，而不是一顺的操作往下直接执行。
    - 享元模式
        - 不同方式发布同一个网站
        - 用hashmap充当池
        - 有一点复杂哦
        - JDK中integer中用到了享元模式
    - 代理模式
        - java反射里面就有代理模式
        - 静态代理：代理教师，代理对象与目标对象要实现相同的接口；钢铁侠的钢铁是代理对象，目标对象是Tony Stark哈哈哈。proxy中用构造器组合一个目标对象的实例。
        - 动态代理：使用JDK的代理类
        - Cglib代理(在内存动态的)：Cglib是一个强大的高性能的代码，被广泛运用于Spring Aop，实现方法拦截。  
- 行为型模式（11）【考得最多？】
    - 模版方法模式
        - 豆浆制作问题，选材-配料-浸泡-放到豆浆机打碎。
    - 命令模式
        - 智能家居。和外观模式有所不同。
        - 遥控，On/off，commond，execute/undo，具体的tvonRemote中有tv.execute/undo
        - JDBC template 用到了命令模式。
    - 访问者模式
        - 对歌手的测评系统。
        - 如果一个系统有比较稳定的数据结构（男人女人 element），又有经常变化的功能需求（成功、失败 visit），那么访问者模式就是比较合适的
    - 迭代器模式    
        - 学校院系，用统一的方式遍历不同集合的遍历
        - 常见的设计模式。每个聚合对象都有一个迭代器，生成多个迭代器不好管理。
    - 观察者模式
        - 天气预报的项目，设计开放性API，便于第三方接入获取数据。数据更新之后实时通知用户。
        - 
    - 中介者模式、
    - 备忘录模式、
    - 解释器模式（Interpreter模式）、
    - 状态模式、
    - 策略模式、
    - 职责链模式(责任链模式)