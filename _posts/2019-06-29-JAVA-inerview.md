---
layout: post
title: java总结
tags: interview java
categories: interview
---

来杯咖啡吧~~<br>
<br>

###真题
- 阿里真题
    - 自己的面试的真题
    - https的加密方式，原理
    - hashmap的结构，hash一致性
    - concurrenthash在hashmap之上的改变
    - jvm的GC机制
    - jvm调优的方法
    - CMS的STW在哪
        - 
    - 有没有接触过开源的框架？
        - 可以回答redis
    - java类加载器有哪些
        -Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个
            - 启动（Bootstrap）类加载器  扩展（Extension）类加载器  系统（System）类加载器
            - 代理模式:双亲委派模型的工作过程如下：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围内没找到这个类）时，自加载器才会尝试自己加载。
            - 代理模式:双亲委派模型是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过双亲委派模型，对于 Java 核心库的类的加载工作由启动类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。
            - Class.forName是一个静态方法，同样可以用来加载类。该方法有两种形式：Class.forName(String name, boolean initialize, ClassLoader loader)和 Class.forName(String className)。第一种形式的参数 name表示的是类的全名；initialize表示是否初始化类；loader表示加载时使用的类加载器。第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。
            - 
    - java反射机制及应用
        - 反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。
        - 反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。
        - 获取反射中的Class对象
            - 第一种，使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。
            - 第二种，使用 .class 方法。
            - 第三种，使用类对象的 getClass() 方法。
        - 通过反射创建类对象   Class 对象的 newInstance() 方法   Constructor 对象的 newInstance() 方法
        - 通过反射获取类属性、方法、构造器
            - getFields() 方法 ;  getDeclaredFields() 
    - synchronized 底层实现，4种锁
        - Java中提供了两种实现同步的基础语义：synchronized方法和synchronized块
        - 重量级锁  重量级锁是我们常说的传统意义上的锁，其利用操作系统底层的同步机制去实现Java中的线程同步。
        - 轻量级锁 
    - FullGC,MinorGC
    - redis主从复制
    - thrift RPC原理
    - Cookie和session的区别
    - 如果登陆了如何其他服务器知道
    - SSO原理，应用场景
    - springboot 和 springmvc 和 spring 区别
    - 缓存一致性
    - 类加载机制
    - arryalist和linkedlist的区别
    - 公平锁原理
    - 联合索引
    - concurrentHashMap实现原理 全部锁住的情况
    - 红黑树的规则
    - AQS 结合 公平锁
    - hashmap扩容
    - 反问

### 技术面问题

- 面试题
    - 阿里一面（一个小时左右）
        - 排序算法
        - 简单二叉树
        - 大数相关
        - 实现接口与继承类的区别
        - Object的方法都有哪些
        - 怎么判断两个对象相等？
        - equals和hashCode
        - hash冲突
        - hashmap的一致性哈希
        - HashMap的底层模型
        - ConcurrentHashMap
        - 刚才提到了segment继承于ReetrantLock，那谈谈Synchronized和Lock的区别
        - CAS
            - CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。CAS也是现在面试经常问的问题
            - CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。
            - CAS的缺点
                - 循环时间长开销很大：我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。
                - 只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。
                - 什么是ABA问题？ABA问题怎么解决？
                    如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？
                    如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。
        

        - 死锁举例
        - JVM类加载机制
        - tcp三次握手四次挥手
        - mysql引擎 B+树
        - MyISAM和InnoDB区别
        - Java final volatile 关键字 volatile指令重排序 举个重排序例子
            - volatile只能保证可见性，无法保证原子性，而自增操作并不是一个原子操作（如下图所示）
                - 首先我们想到的是用synchronized来修饰increase方法。 每次自增都进行加锁，性能可能会稍微差了
                - Java并发包原子操作类（Atomic开头）  race改成使用AtomicInteger定义，“race++”改成使用“race.getAndIncrement()”，AtomicInteger.getAndIncrement()是原子操作，因此我们可以确保每次都可以获得正确的结果。通过方法调用，我们可以发现，getAndIncrement方法调用getAndAddInt方法，最后调用的是compareAndSwapInt方法，即本文的主角CAS，接下来我们开始介绍CAS。
            - volatile关键字可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。了解volatile变量的语义对了解多线程操作的其他特性很有意义
            - volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。
            - 当一个变量定义为volatile之后，它将具备两种特性。 保证此变量对所有线程的可见性，即当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。
            - 禁止指令重排序优化。 
            - volatile变量在各个线程的工作内存中不存在一致性问题，但是Java里面的运算并非原子操作，并且volatile并不能保证原子性，导致volatile变量的运算在并发下一样是不安全的，我们可以通过一段简单的演示来说明原因，请看下面的例子。
            
        - JVM对Java做了什么 堆和栈 垃圾回收算法
        - 网络 打开网页 怎么用拥塞控制 路由寻路 TCP UDP区别
        - 数据结构 树的变种 b+和红黑树
        - 操作系统 线程和进程 为什么切换进程消耗小 什么时候进程什么时候线程 虚拟内存 页式存储
        - 数据库 事务 隔离级别
        - 什么是分布式事务 怎么做
        - 分布式锁
        - 场景题 额度调整不加锁
        - 项目分析 场景
        - spring ioc aop springboot差别
        - 分布式理解 心得
        - paxos和raft
        - 有什么想问我
        - [https](https://my.oschina.net/u/1778933/blog/421775)
    - 阿里二面
        - 了解设计模式吗？
        - HTTP协议和IP协议
        - GC是如何做到的，哪些作为GC root
        - JavaNIO和IO区别，如果分别用他们实现QQ有什么区别
        - HashMap线程安全吗，多线程什么问题
        - ArrayList多线程什么问题
        - 线程池知道吗？为什么用线程池，有什么好处
        - 栈上的空间什么时候分配的
        - 实现分布式锁
        - 聊聊ZK和Consul
        - ZK的实现，他是用来干嘛的
        - 你们部门的业务处于公司怎样的一个环节
        - 评价下自己，平时有什么爱好
        - 如何做好一件事情
- [java 缓存一致性]
    - 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），如下图所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及 Dragon Protocol等。在本文中将会多次提到的“内存模型”一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问操作具有很高的可比性。
    - 除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。

- [史上最全阿里面试题](https://zhuanlan.zhihu.com/p/46144296)
- [知名公司的java面试题](https://www.techug.com/post/java-volatile-keyword.html)
- JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。
- [经典的133个问题列表]()
- [乐观锁](https://www.cnblogs.com/Mainz/p/3546347.html)
    - [两种锁的使用场景 和 ](https://juejin.im/post/5b4977ae5188251b146b2fc8)
    从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。
- 请你解释Object若不重写hashCode()的话，hashCode()如何计算出来的？
    - Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。
- 请你解释为什么重写equals还要重写hashcode？
    - 因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的
- 请你介绍一下map的分类和常见的情况
    - java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap.
    - Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。
    - Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。
    - HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。
    - HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。
    - Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。
    - LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。
    在遍历的时候会比HashMap慢.
    - TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。
- final
    - 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
-  请你谈谈关于Synchronized和lock 
    - synchronized是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。
    Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
- 请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？
    - synchronized修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。
- [若对一个类不重写，它的equals()方法是如何比较的？][若对一个类不重写，它的equals()方法是如何比较的？]
- [请解释hashCode()和equals()方法有什么联系？][若对一个类不重写，它的equals()方法是如何比较的？]
- 内存置换算法 FIFO LRU LFU OPT clock
- 缓存系统如何提高命中率
- TCP/IP 三四 滑动窗口协议
- 数据库索引数据结构  哈希，B+树索引，优劣及应用比较，时间复杂度分析
- IO多路复用，五大IO模型，
- 你知道java8的新特性吗，请简单介绍一下
    - Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。
    - Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。



- 


[若对一个类不重写，它的equals()方法是如何比较的？](https://www.nowcoder.com/tutorial/94/965a74a5195b4904a9106aee097a9a3a)
- java buffer机制
- mapreduce
- 进程通信
- gc设计模式
- 面向对象的特征
- final, finally, finalize 的区别
- int 和 Integer 有什么区别
- 重载和重写的区别
- 
- 抽象类和接口有什么区别
- 
- 说说反射的用途及实现
- 
- 说说自定义注解的场景及实现
- 
- HTTP 请求的 GET 与 POST 方式的区别
- 
- session 与 cookie 区别
- 
- session 分布式处理
- 
- JDBC 流程
- 
- MVC 设计思想
- 
- equals 与 == 的区别
- 
- 集合
- List 和 Set 区别
- 
- List 和 Map 区别
- 
- Arraylist 与 LinkedList 区别
- 
- ArrayList 与 Vector 区别
- 
- HashMap 和 Hashtable 的区别
- 
- HashSet 和 HashMap 区别
- 
- HashMap 和 ConcurrentHashMap 的区别
- 
- HashMap 的工作原理及代码实现
- 
- ConcurrentHashMap 的工作原理及代码实现
- 
- 线程
- 创建线程的方式及实现
- 
- sleep() 、join（）、yield（）有什么区别
- 
- 说说 CountDownLatch 原理
- 
- 说说 CyclicBarrier 原理
- 
- 说说 Semaphore 原理
- 
- 说说 Exchanger 原理
- 
- 说说 CountDownLatch 与 CyclicBarrier 区别
- 
- ThreadLocal 原理分析
- 
- 讲讲线程池的实现原理
- 
- 线程池的几种方式
- 
- 线程的生命周期
- 
- 锁机制
- 说说线程安全问题
- 
- volatile 实现原理
- 
- synchronize 实现原理
- 
- synchronized 与 lock 的区别
- 
- CAS 乐观锁
- 
- ABA 问题
- 
- 乐观锁的业务场景及实现方式
- 
- 核心篇
- 数据存储
- MySQL 索引使用的注意事项
- 
- 说说反模式设计
- 
- 说说分库与分表设计
- 
- 分库与分表带来的分布式困境与应对之策
- 
- 说说 SQL 优化之道
- 
- MySQL 遇到的死锁问题
- 
- 存储引擎的 InnoDB 与 MyISAM
- 
- 数据库索引的原理
- 
- 为什么要用 B-tree
- 
- 聚集索引与非聚集索引的区别
- 
- limit 20000 加载很慢怎么解决
- 
- 选择合适的分布式主键方案
- 
- 选择合适的数据存储方案
- 
- ObjectId 规则
- 
- 聊聊 MongoDB 使用场景
- 
- 倒排索引
- 
- 聊聊 ElasticSearch 使用场景
- 
- 缓存使用
- Redis 有哪些类型
- 
- Redis 内部结构
- 
- 聊聊 Redis 使用场景
- 
- Redis 持久化机制
- 
- Redis 如何实现持久化
- 
- Redis 集群方案与实现
- 
- Redis 为什么是单线程的
- 
- 缓存奔溃
- 
- 缓存降级
- 
- 使用缓存的合理性问题
- 
- 消息队列
- 消息队列的使用场景
- 
- 消息的重发补偿解决思路
- 
- 消息的幂等性解决思路
- 
- 消息的堆积解决思路
- 
- 自己如何实现消息队列
- 
- 如何保证消息的有序性
- 
- 框架篇
- Spring
- BeanFactory 和 ApplicationContext 有什么区别
- 
- Spring Bean 的生命周期
- 
- Spring IOC 如何实现
- 
- 说说 Spring AOP
- 
- Spring AOP 实现原理
- 
- 动态代理（cglib 与 JDK）
- 
- Spring 事务实现方式
- 
- Spring 事务底层原理
- 
- 如何自定义注解实现功能
- 
- Spring MVC 运行流程
- 
- Spring MVC 启动流程
- 
- Spring 的单例实现原理
- 
- Spring 框架中用到了哪些设计模式
- 
- Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring - AMQP 等）
- 
- Netty
- 为什么选择 Netty
- 
- 说说业务中，Netty 的使用场景
- 
- 原生的 NIO 在 JDK 1.7 版本存在 epoll bug
- 
- 什么是TCP 粘包/拆包
- 
- TCP粘包/拆包的解决办法
- 
- Netty 线程模型
- 
- 说说 Netty 的零拷贝
- 
- Netty 内部执行流程
- 
- Netty 重连实现
- 
- 微服务篇
- 微服务
- 前后端分离是如何做的
- 
- 微服务哪些框架
- 
- 你怎么理解 RPC 框架
- 
- 说说 RPC 的实现原理
- 
- 说说 Dubbo 的实现原理
- 
- 你怎么理解 RESTful
- 
- 说说如何设计一个良好的 API
- 
- 如何理解 RESTful API 的幂等性
- 
- 如何保证接口的幂等性
- 
- 说说 CAP 定理、 BASE 理论
- 
- 怎么考虑数据一致性问题
- 
- 说说最终一致性的实现方案
- 
- 你怎么看待微服务
- 
- 微服务与 SOA 的区别
- 
- 如何拆分服务
- 
- 微服务如何进行数据库管理
- 
- 如何应对微服务的链式调用异常
- 
- 对于快速追踪与定位问题
- 
- 微服务的安全
- 
- 分布式
- 谈谈业务中使用分布式的场景
- 
- Session 分布式方案
- 
- 分布式锁的场景
- 
- 分布是锁的实现方案
- 
- 分布式事务
- 
- 集群与负载均衡的算法与实现
- 
- 说说分库与分表设计
- 
- 分库与分表带来的分布式困境与应对之策
- 
- 安全&性能
- 安全问题
- 安全要素与 STRIDE 威胁
- 
- 防范常见的 Web 攻击
- 
- 服务端通信安全攻防
- 
- HTTPS 原理剖析
- 
- HTTPS 降级攻击
- 
- 授权与认证
- 
- 基于角色的访问控制
- 
- 基于数据的访问控制
- 
- 性能优化
- 性能指标有哪些
- 
- 如何发现性能瓶颈
- 
- 性能调优的常见手段
- 
- 说说你在项目中如何进行性能调优
- 
- 工程篇
- 需求分析
- 你如何对需求原型进行理解和拆分
- 
- 说说你对功能性需求的理解
- 
- 说说你对非功能性需求的理解
- 
- 你针对产品提出哪些交互和改进意见
- 
- 你如何理解用户痛点
- 
- 设计能力
- 说说你在项目中使用过的 UML 图
- 
- 你如何考虑组件化
- 
- 你如何考虑服务化
- 
- 你如何进行领域建模
- 
- 你如何划分领域边界
- 
- 说说你项目中的领域建模
- 
- 说说概要设计
- 
- 设计模式
- 你项目中有使用哪些设计模式
- 
- 说说常用开源框架中设计模式使用分析
- 
- 说说你对设计原则的理解
- 
- 23种设计模式的设计理念
- 
- 设计模式之间的异同，例如策略模式与状态模式的区别
- 
- 设计模式之间的结合，例如策略模式+简单工厂模式的实践
- 
- 设计模式的性能，例如单例模式哪种性能更好。
- 
- 业务工程
- 你系统中的前后端分离是如何做的
- 
- 说说你的开发流程
- 
- 你和团队是如何沟通的
- 
- 你如何进行代码评审
- 
- 说说你对技术与业务的理解
- 
- 说说你在项目中经常遇到的 Exception
- 
- 说说你在项目中遇到感觉最难Bug，怎么解决的
- 
- 说说你在项目中遇到印象最深困难，怎么解决的
- 
- 你觉得你们项目还有哪些不足的地方
- 
- 你是否遇到过 CPU 100% ，如何排查与解决
- 
- 你是否遇到过 内存 OOM ，如何排查与解决
- 
- 说说你对敏捷开发的实践
- 
- 说说你对开发运维的实践
- 
- 介绍下工作中的一个对自己最有价值的项目，以及在这个过程中的角色
- 
- 软实力
- 说说你的亮点
- 
- 说说你最近在看什么书
- 
- 说说你觉得最有意义的技术书籍
- 
- 工作之余做什么事情
- 
- 说说个人发展方向方面的思考
- 
- 说说你认为的服务端开发工程师应该具备哪些能力
- 
- 说说你认为的架构师是什么样的，架构师主要做什么
- 
- 说说你所理解的技术专家
- 