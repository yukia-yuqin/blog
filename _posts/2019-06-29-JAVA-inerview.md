---
layout: post
title: java总结
tags: interview java
categories: interview
---

来杯咖啡吧~~<br>
<br>

###真题
- 阿里真题
    - 4、面试内容
    - 考察内容会相对偏基础，给大家一个参考范围（不限于以下内容）：1）基础知识
    - 算法与数据结构（可能有在线编程1-2道，难度是 easy middle 之间）：排序算法，简单的二叉树，大数相关
    - 操作系统与网络：多线程与多进程，内存分页，磁盘管理，死锁及如何避免，http(s)协议的安全性，tcp三次握手与可靠传输
    - 数据库：乐观锁与悲观锁，数据库索引的底层数据结构，数据库的原子性
    - 2）编程语言（Java为例）：HashMap扩容、一致性hash，ConcurrentHashMap，GC原理，Integer与int差别，设计模型（单例、工厂等），NIO等
    - 3）项目经验：描述清楚项目背景，项目的实现与技术难点，自己在项目中的贡献，上述也适用于论文
    - 4）开放题：一般在最后两轮面试会有，主要考察理解能力和反应能力
    - 二面也是技术面，对简历里面的项目再总结一下哈，可以说清楚项目的意义、如何做、碰到的问题与解决方法；再就是一些基础相关的，可以理解原理并思考原因
    - 多进程与多线程
        - 
    - https
        - ssh https://blog.csdn.net/liubo2012/article/details/8894143
        - 先说结论，在【加密】这种场景下，公钥用来加密，私钥用来解密。
        - 公钥的英文是public key，所以可以被别人知道，Bob用Alice的公钥对消息进行加密，并把加密之后的消息传回给Alice；私钥的英文是private key，Alice应该保存好与这个公钥相对应的私钥，不能被别人知道，当Alice收到Bob发来的加密过的消息后，通过手里的私钥对其进行解密。只有私钥可以解密，而公钥不可以，所以即使公钥被窃听者Eve知道也没有关系。
        - 好的，在理解了上述过程之后，我们来说说【签名】这个场景。签名是对上述过程的反向应用，即在此场景下，用私钥进行“加密”，而公钥进行“解密”，这种说法是使题主头晕的原因，所以更清晰的说法是：在此场景下，用私钥进行“签名”，用公钥进行“认证”。因为私钥只有Alice自己知道，所以用私钥对消息进行签名后，只有与之对应的公钥才能对这个签过名的消息进行认证，而公钥又是任何人都可以获取的，所以通过这个过程可以知道该消息确实是属于Alice的。
    - 一致性hash
        - 就是说，”一致性哈希，就是提供一个hashtable,它能在节点加入离开时不会导致映射关系的重大变化“
        - 分布式一致性hash。如果Server的哈希等于Key的哈希，则把Key存放在该Server上；否则，寻找第一个大于Key哈希的Server，用于存放Key。但有Server增加、删除时，只要变动周边的Server映射关系即可，不用全部重新哈希。之所以有这样优良的特性是因为，Server和Key采用了同样的值域。还有最后一个问题，虚节点是如何产生的呢？也非常简单，就是在每个Server加个后缀，在做MD5哈希，取其32位。
    - MD5哈希
        - MD5的结果为一个160bit的数字，取其前32位作为一个Integer
    - hashmap
        -  当使用HashMap时，key被均匀地映射到数组之上，映射方法就是利用key的hash与数组长度取模(通过&运算)。  当put的数据超过负载因子loadFactor×2Len时，HashMap会按照2被的容量扩容。新put进来的数据会通过与新数组的长度取模的方式进行映射。那之前已经映射的数据该怎么办？通过查看HashMap代码的resize方法会发现，每次扩容都会把之前的key重新映射。  所以对HashMap而言要想获得较好的性能必须要提前估计所放数据集合的大小，以设计合适的初始化容量和负载因子。

    - cms停顿了几次？为什么要有这些停顿？ https://zhuanlan.zhihu.com/p/42934904
        - CMS并非没有暂停，而是用两次短暂停来替代串行标记整理算法的长暂停，它的收集周期是这样：初始标记(CMS-initial-mark) -> 并发标记(CMS-concurrent-mark) -> 重新标记(CMS-remark) -> 并发清除(CMS-concurrent-sweep) ->并发重设状态等待下次CMS的触发(CMS-concurrent-reset)。其中的1，3两个步骤需要暂停所有的应用程序线程的。第一次暂停从root对象开始标记存活的对象，这个阶段称为初始标记；第二次暂停是在并发标记之后， 暂停所有应用程序线程，重新标记并发标记阶段遗漏的对象（在并发标记阶段结束后对象状态的更新导致）。第一次暂停会比较短，第二次暂停通常会比较长，并且 remark这个阶段可以并行标记。

    - https加密 https://www.jianshu.com/p/b894a7e1c779
        - 如果和你建立安全连接的人带着这些人的签名，那么认为这个安全连接是安全的，没有遭到中间人攻击。通过 对称加密 + 非对称加密 + CA认证 这三个技术混合在一起，才使得 HTTP 的后面加上了一个 S —— Security。实际上 HTTPS 的协议比我这里描述的更复杂一些，我这里说的主要是基本的实现原理。因为其中任何一环稍有闪失，就会使得整个加密都将变得不安全。这也是为什么 HTTPS 的加密协议从SSL 1.0 升级到 SSL 3.0 再被 TLS 1.0 现在被 TLS 1.2 取代，其背后都是一环环细节上的修改，以防任何地方的闪失。这是因为 非对称加密 的密码对生成和加密的消耗时间比较长，为了节省双方的计算时间，通常只用它来交换密钥，而非直接用来传输数据。


    - java类加载器有哪些
        -Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个（https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html）
            - 基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例。下面详细介绍这个 Java 类。表 1. ClassLoader 中与加载类相关的方法:getParent();loadClass(String name);findClass(String name);findLoadedClass(String name);defineClass(String name, byte[] b, int off, int len);resolveClass(Class<?> c)	
            -  方法 loadClass()抛出的是 java.lang.ClassNotFoundException异常；方法 defineClass()抛出的是 java.lang.NoClassDefFoundError异常。
            - 启动（Bootstrap）类加载器  扩展（Extension）类加载器  系统（System）类加载器
            - 代理模式:双亲委派模型的工作过程如下：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围内没找到这个类）时，自加载器才会尝试自己加载。
            - 代理模式:双亲委派模型是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过双亲委派模型，对于 Java 核心库的类的加载工作由启动类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。
            - Class.forName是一个静态方法，同样可以用来加载类。该方法有两种形式：Class.forName(String name, boolean initialize, ClassLoader loader)和 Class.forName(String className)。第一种形式的参数 name表示的是类的全名；initialize表示是否初始化类；loader表示加载时使用的类加载器。第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。
            - 
    - java反射机制及应用
        - 反射则是一开始并不知道我要的类对象是什么，自然也无法使用 new 关键字来创建对象了。反射就是在运行时才知道要初始化/操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。
        - 获取反射中的Class对象
            - 第一种，使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。 Class.forName("类的路径").
            - 第二种，使用 .class 方法。类名.class；
            - 第三种，使用类对象的 getClass() 方法。实例.getClass()。
        - 通过反射创建类对象   Class 对象的 newInstance() 方法   Constructor 对象的 newInstance() 方法
        - 反射的功能：通过反射获取类属性、成员变量和方法、构造器，在运行时创建对象，在运行时调用对象的方法
            - getFields() 方法 ;  getDeclaredFields() 
    - synchronized 底层实现，4种锁。https://blog.csdn.net/javazejian/article/details/72828483
        - 为什么会有线程安全问题：一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据。当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行，这种方式叫互斥锁，当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。在 Java 中，关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到synchronized另外一个重要的作用，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能），这点确实也是很重要的。
        - synchronized底层语义原理：Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的。对于顶部，则是Java头对象，它实现synchronized的锁对象的基础。synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度。其中Mark Word在默认情况下存储着对象的HashCode、分代年龄、锁标记位等以下是32位JVM的Mark Word默认存储结构


        - Java中提供了两种实现同步的基础语义：synchronized方法和synchronized块
        - 重量级锁  重量级锁是我们常说的传统意义上的锁，其利用操作系统底层的同步机制去实现Java中的线程同步。synchronized的对象锁，锁标识位为10，每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的
            - synchronized代码块底层原理。字节码中可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。
            - synchronized方法底层原理。方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。同时我们还必须注意到的是在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了，Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，
        - 锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。
        - 偏向锁
            - 偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。
        - 轻量级锁
            - 倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。
        - 自旋锁
            - 虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。
        - 锁消除
        - synchronized的可重入性
            - 从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性
    
    - FullGC,MinorGC https://youzhixueyuan.com/the-difference-between-minor-gc-major-gc-full-gc.html
        - 年轻代是所有新对象产生的地方。当年轻代内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫做Minor GC。年轻代被分为3个部分——Enden区和两个Survivor区。
        - Minor GC和Major GC其实就是年轻代GC和年老年GC的俗称。而在Hotspot VM具体实现的收集器：Serial GC, Parallel GC, CMS, G1 GC中，大致可以对应到某个Young GC和Old GC算法组合。
        - 当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区。
        - Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区。
        - 经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。
        - Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。永远有一个survivor space是空的，另一个非空的survivor space无碎片。
        - Full GC定义是相对明确的，就是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC。
        - 下图中的Perm代表的是永久代，但是注意永久代并不属于堆内存中的一部分，同时jdk1.8之后永久代已经被移除。
        - 方法区也称”永久代“，它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。
        -  -Xms设置堆的最小空间大小。
        -  -Xmx设置堆的最大空间大小。
        -  -Xmn:设置年轻代大小。
        -  -XX:NewSize设置新生代最小空间大小。
        -  -XX:MaxNewSize设置新生代最大空间大小。
        -  -XX:PermSize设置永久代最小空间大小。
        -  -XX:MaxPermSize设置永久代最大空间大小。
        -  -Xss设置每个线程的堆栈大小。
        -  -XX:+UseParallelGC:选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集。
        -  -XX:ParallelGCThreads=20:配置并行收集器的线程数,即:同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等
        - 深入详解JVM内存模型与JVM参数详细配置  https://youzhixueyuan.com/jvm-memory-model-and-parameter-configuration.html
        - 垃圾回收算法：1.标记清除 https://youzhixueyuan.com/jvm-garbage-collection-algorithm.html
        - 4.分代收集算法。分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。 
        - 1.新生代的收集器包括：Serial/PraNew/Parallel Scavenge。 https://youzhixueyuan.com/jvm-garbage-collector.html
        - 2.老年代的收集器包括：Serial Old/Parallel Old/CMS
        - 3.回收整个Java堆(新生代和老年代)：G1收集器
        - jvm调优过程
            - https://youzhixueyuan.com/jvm-performance-optimization.html

    - redis主从复制
        - redis: https://segmentfault.com/a/1190000017339258
        - 主从复制是为了数据备份
        - Redis是一个Key-Value存储系统，它支持存储的value类型很多，包括string、list（链表）、set（集合）、zset（有序集合）。这些数据类型都支持push/pop、add/remove以及取交集和并集等丰富的操
        - hash：通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。
        - list：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。
        - set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。
        - Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。
    - thrift RPC原理
    - Cookie和session的区别
        - cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。
        - 和session的区别是：cookie数据保存在客户端，session数据保存在服务器端。
        - Cookie：
        - 1.Cookie是将会话状态保存在浏览器的技术；
        - 2.Cookie中的数据保存时间较长(可调)；
        - 3.Cookie数据的安全性和稳定性较差(原因是数据保存在用户手中，用户可进行任意修改，病毒可轻易攻击)；
        - 4.Cookie的大小有限制，大小约为4kb。
        - Session
        - 1.Session是将会话状态保存在服务器的技术；
        - 2.Session中的数据保存时间较短，约为30分钟(可调)；
        - 3.Session数据的安全性和稳定性较高(服务器的安全性高，数据存在服务器上安全性高)；
        - 4.Session的大小无限制，理论上可无限大(Session是存在服务器的内存中的，当Session的大小超出内存可承受范- 围，就会自动存储到服务器的硬盘中)
    - 如果登陆了如何其他服务器知道
    - SSO原理，应用场景
        - 单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。
        - 分布式session方式实现单点登录
            - 例如阿里有很多系统分割为多个子系统，独立部署后，不可避免的会遇到会话管理的问题，类似这样的电商网站一般采用分布式Session实现。再进一步可以根据分布式Session，建立完善的单点登录或账户管理系统。
    - springboot 和 springmvc 和 spring 区别
    - 缓存一致性
    - arryalist和linkedlist的区别
        - 1. ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构；
        - 2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；
        - 3. 对于添加和删除操作add和remove，一般大家都会说LinkedList要比ArrayList快，因为ArrayList要移动数据。但是实际情况并非这样，对于添加或删除，LinkedList和ArrayList并不能明确说明谁快谁慢，下面会详细分析。
    - 公平锁原理
        - 公平锁在锁释放后会严格按照等到队列去取后续值，而非公平锁在对于新晋线程有很大优势。
    - 联合索引
        - 两个或更多个列上的索引被称作联合索引，联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。
    - concurrentHashMap实现原理 全部锁住的情况
    - 红黑树的规则
        - 节点是红色或黑色;根是黑色;所有叶子都是黑色（叶子是NIL节点）;每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）;从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
    - AQS 结合 公平锁
        - AQS底层机制.对java并发机制熟悉的人都知道底层基本上都是基于AQS实现的,即AbstractQueuedSynchronizer.而且AQS里面又维护了一个队列,可以实现线程排队机制,也可以做等待唤醒操作。那到底公平锁和非公平锁的区别在哪？仔细看一下,NonfairSync中的lock方法首先会通过CAS修改state,而FairSync则直接通过acquire获取。因为acquire最终还是通过CAS修改state,只是里面内置了排队机制.而非公平锁则直接修改state的值,无需排队。
    - hashmap扩容
    - 反问
        - 公司技术栈
    - LVS负载均衡怎么支持高并发，负载均衡发生在网络的哪一层
        - LVS是四层负载均衡，也就是说建立在OSI模型的第四层——传输层之上，传输层上有我们熟悉的TCP/UDP，LVS支持TCP/UDP的负载均衡。
    - 讲一下OSI7层模型，传输层是干什么的
        - https://blog.csdn.net/u011774517/article/details/67631439
    - 讲一下URL之后发生了什么
        - 1.DNS域名解析；2.建立TCP连接；3.发送HTTP请求；4.服务器处理请求；5.返回响应结果；6.关闭TCP连接；7.浏览器解析HTML；8.浏览器布局渲染；
    - 讲一下TCP和UDP的区别
        - 1.基于连接与无连接； 
        - 2.对系统资源的要求（TCP较多，UDP少）； 
        - 3.UDP程序结构较简单； 
        - 4.流模式与数据报模式 ；
        - 5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。
    - TCP是如何实现可靠传输的
        - TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。
    - DNS用的什么协议
        - DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议； 
            - DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 
            - 为什么既使用TCP又使用UDP？ 
                首先了解一下TCP与UDP传送字节的长度限制： 
                UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。 
            - 区域传送时使用TCP，主要有一下两点考虑： 
                1.辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 
                2.TCP是一种可靠的连接，保证了数据的准确性。 
            - 域名解析时使用UDP协议： 
                客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。
    - 数据库索引B树和B+树有什么区别，B+树的高度何时发生改变
        - 卫星数据：指的是索引元素所指向的数据记录。比如数据库中的某一行。B树中无论中间节点还是叶子节点都带有卫星数据。B+树中，只有叶子节点带卫星数据，其他中间节点仅仅是索引，没有数据关联。
        - 综合起来，B+树比B-树优势有三个：1、IO次数更少2、查询性能稳定3、范围查询简便。
    - 创建索引的过程
    - Like查询的过程
    - hashmap hash函数，讲一下hashmap size是怎么获取的，是线程安全的吗
        - 大家都知道上面代码里的key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值。“扰动函数”的价值就体现出来了，说到这里大家应该猜出来了。看下面这个图，
        - 其实简单，我们只要调用Object对象的hashCode()方法，该方法会返回一个整数，然后用这个数对HashMap或者HashTable的容量进行取模就行了。没错，其实基本原理就是这个，只不过，在具体实现上，由两个方法int hash(Object k)和int indexFor(int h, int length)来实现。但是考虑到效率等问题，HashMap的实现会稍微复杂一点。hash ：该方法主要是将Object转换成一个整型。indexFor ：该方法主要是将hash生成的整型转换成链表数组中的下标。indexFor方法其实主要是将hash生成的整型转换成链表数组中的下标。那么return h & (length-1);是什么意思呢？其实，他就是取模。Java之所有使用位运算(&)来代替取模运算(%)，最主要的考虑就是效率。位运算(&)效率要比代替取模运算(%)高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。
        - 这段代码是为了对key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。简单点说，就是为了把高位的特征和低位的特征组合起来，降低哈希冲突的概率，也就是说，尽量做到任何一位的变化都能对最终得到的结果产生影响。
        - 我们可以发现，为了保证哈希的结果可以分散、为了提高哈希的效率，JDK在一个小小的hash方法上就有很多考虑，做了很多事情。当然，我希望我们不仅可以深入了解背后的原理，还要学会这种对代码精益求精的态度。
    - 如何用最短时间复杂度内找到一颗二叉树内距离最远的两个节点。
    - 一个数组如何创建一棵平衡二叉树
        - 二分：用有序数组中中间的数生成搜索二叉树的头节点，然后对数组的左右部分分别生成左右子树即可（重复过程）。生成的二叉树中序遍历一定还是这个序列。
- 百度真题
    - 面项目数据库，全程怼数据库（数据库索引优化，联合索引，如何建立索引，数据分裤分表，种类使用场景，如何对数据进行分裤有哪些方式）。面项目数据库（写出数据的表结构表中的字段，表之间的关联，用ER图画，不会，忘了。他说没关系，现在让你设计这个数据库表结构你会如何设计，设计完后，他说需求我写sql语句。我写的比较low，他们会不会数据库连接，左连接，右连接，全链接等）

### 技术面问题

- 面试题
    - 阿里一面（一个小时左右）
        - 排序算法
        - 简单二叉树
        - 大数相关
        - 实现接口与继承类的区别
            - 一个类只能继承一个类，但是可以实现多个接口。接口里面的方法都是抽象方法，必须要重写所有的方法。接口抽象的方法都要被重写，而继承的类不必这样。继承一般开发中用的会相比少一点,接口相比就应该会多一点.，接口主要是实现一种松耦合，便于以后的维护、升级，继承主要是提高代码的可重用性，很多东西都可以在父类中做好。子类可以直接用.
        - Object的方法都有哪些 https://zhb1208.iteye.com/blog/1418324
        - 怎么判断两个对象相等？
            - equals通常用来比较两个对象的内容是否相等，==用来比较两个对象的地址是否相等。Object类中的equals方法定义为判断两个对象的地址是否相等（可以理解成是否是同一个对象），地址相等则认为是对象相等。这也就意味着，我们新建的所有类如果没有复写equals方法，那么判断两个对象是否相等时就等同于“==”，也就是两个对象的地址是否相等。1、类未复写equals方法，则使用equals方法比较两个对象时，相当于==比较，即两个对象的地址是否相等。地址相等，返回true，地址不相等，返回false.2、类复写equals方法，比较两个对象时，则走复写之后的判断方式。通常，我们会将equals复写成：当两个对象内容相同时，则equals返回true，内容不同时，返回false。
        - equals和hashCode
            - hashCode的作用及与equals的关系。hashCode的作用是用来获取哈希码，也可以称作散列码。实际返回值为一个int型数据。用于确定对象在哈希表中的位置。Object中有hashcode方法，也就意味着所有的类都有hashCode方法。但是，hashcode只有在创建某个类的散列表的时候才有用，需要根据hashcode值确认对象在散列表中的位置，但在其他情况下没用。
        - hash冲突
        - hashmap的一致性哈希
        - HashMap的底层模型
            - JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的时数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。
            - 红黑树特点:每个节点非红即黑；根节点总是黑色的；每个叶子节点都是黑色的空节点（NIL节点）；如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）;
            - 红黑树的应用：TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。
            - 为什么要用红黑树:简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。
            - 红黑树这么优秀,为何不直接使用红黑树得了?
                - 说一下自己对于这个问题的看法：我们知道红黑树属于（自）平衡二叉树，但是为了保持“平衡”是需要付出代价的，红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，这费事啊。你说说我们引入红黑树就是为了查找数据快，如果链表长度很短的话，根本不需要引入红黑树的，你引入之后还要付出代价维持它的平衡。但是链表过长就不一样了。至于为什么选 8 这个值呢？通过概率统计所得，这个值是综合查询成本和新增元素成本得出的最好的一个值。
            - HashSet 和 HashMap 区别:如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的
            - HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。
        - ConcurrentHashMap
            - ConcurrentHashMap 和 Hashtable 的区别
            - ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。
            - 底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；
            - 实现线程安全的方式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁)：使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。
        - 刚才提到了segment继承于ReetrantLock，那谈谈Synchronized和Lock的区别
        - CAS
            - CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。CAS也是现在面试经常问的问题
            - CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。
            - CAS的缺点
                - 循环时间长开销很大：我们可以看到getAndAddInt方法执行时，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。
                - 只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。
                - 什么是ABA问题？ABA问题怎么解决？
                    如果内存地址V初次读取的值是A，并且在准备赋值的时候检查到它的值仍然为A，那我们就能说它的值没有被其他线程改变过了吗？
                    如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。
        

        - 死锁举例
            - 第一种synchronized方式死锁：线程thread1先获取锁locka，然后在同步块里嵌套竞争锁lockb。而线程thread2先获取锁lockb，然后在同步块里嵌套竞争锁locka
            - 第二种concurrent包Lock错误使用，导致死锁：java两种经典死锁例子，Lock发生死锁案列.
        - JVM类加载机制
        - tcp三次握手四次挥手为什么切换进程消耗小
        - mysql引擎 B+树
        - MyISAM和InnoDB区别
        - Java final volatile 关键字 volatile指令重排序 举个重排序例子
            - volatile只能保证可见性，无法保证原子性，而自增操作并不是一个原子操作（如下图所示）
                - 首先我们想到的是用synchronized来修饰increase方法。 每次自增都进行加锁，性能可能会稍微差了
                - Java并发包原子操作类（Atomic开头）  race改成使用AtomicInteger定义，“race++”改成使用“race.getAndIncrement()”，AtomicInteger.getAndIncrement()是原子操作，因此我们可以确保每次都可以获得正确的结果。通过方法调用，我们可以发现，getAndIncrement方法调用getAndAddInt方法，最后调用的是compareAndSwapInt方法，即本文的主角CAS，接下来我们开始介绍CAS。
            - volatile关键字可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。了解volatile变量的语义对了解多线程操作的其他特性很有意义
            - volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。
            - 当一个变量定义为volatile之后，它将具备两种特性。 保证此变量对所有线程的可见性，即当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。
            - 禁止指令重排序优化。 
            - volatile变量在各个线程的工作内存中不存在一致性问题，但是Java里面的运算并非原子操作，并且volatile并不能保证原子性，导致volatile变量的运算在并发下一样是不安全的，我们可以通过一段简单的演示来说明原因，请看下面的例子。
            
        - JVM对Java做了什么 堆和栈 垃圾回收算法
        - 网络 打开网页 怎么用拥塞控制 路由寻路 TCP UDP区别
        - 数据结构 树的变种 b+和红黑树
        - 操作系统 线程和进程 为什么切换线程消耗小 什么时候进程什么时候线程 虚拟内存 页式存储
            - google的： 进程切换比线程切换开销大是因为进程切换时要切页表，而且往往伴随着页调度，因为进程的数据段代码段要换出去，以便把将要执行的进程的内容换进来。本来进程的内容就是线程的超集。而且线程只需要保存线程的上下文（相关寄存器状态和栈的信息）就好了，动作很小
        - 数据库 事务 隔离级别
            - 在说分布式事务之前，我们先从数据库事务说起。 数据库事务可能大家都很熟悉，在开发过程中也会经常使用到。但是即使如此，可能对于一些细节问题，很多人仍然不清楚。比如很多人都知道数据库事务的几个特性：原子性(Atomicity )、一致性( Consistency )、隔离性或独立性( Isolation)和持久性(Durabilily)，简称就是ACID。但是再往下比如问到隔离性指的是什么的时候可能就不知道了，或者是知道隔离性是什么但是再问到数据库实现隔离的都有哪些级别，或者是每个级别他们有什么区别的时候可能就不知道了
        - 什么是分布式事务 怎么做 https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html
            - CAP定理 一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效)；可用性(Availability) ： 每个操作都必须以可预期的响应结束。分区容错性(Partition tolerance) ： 即使出现单个组件无法可用,操作依然可以完成。具体地讲在分布式系统中，在任何数据库设计中，一个Web应用至多只能同时支持上面的两个属性。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在一致性与可用性之间做出选择。
            - 其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段：
            - 第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.
            - 第二阶段：事务协调器要求每个数据库提交数据。
            - BASE理论；Basically Available（基本可用）；Soft state（软状态）；Eventually consistent（最终一致性）
        - 分布式锁
            - 2.1为何需要分布式锁。效率 https://juejin.im/post/5bbb0d8df265da0abd3533a5
            - 5.1Redis分布式锁简单实现
        - 场景题 额度调整不加锁
        - spring ioc aop springboot差别
        - 分布式理解 心得
        - paxos和raft
        - 有什么想问我
        - [https](https://my.oschina.net/u/1778933/blog/421775)
    - 阿里二面
        - 了解设计模式吗？
        - HTTP协议和IP协议
            - TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”
        - GC是如何做到的
        - JavaNIO和IO区别，如果分别用他们实现QQ有什么区别
            - NIO是为了弥补IO操作的不足而诞生的，NIO的一些新特性有：非阻塞I/O，选择器，缓冲以及管道。管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征。1,IO是面向流的，NIO是面向块（缓冲区）的。2，IO是阻塞的，NIO是非阻塞的。
        - HashMap线程安全吗，多线程什么问题
        - ArrayList多线程什么问题
        - 线程池知道吗？为什么用线程池，有什么好处 https://blog.csdn.net/qq_33453910/article/details/81413285
            - 不使用线程池的话，所创建的线程数无法控制，比如一下子创建了几百几千个线程，电脑一下子就崩溃了。1:提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。2:方便管理 可以编写线程池管理代码对池中的线程统一进行管理，比如说系统启动时由该程序创建100个线程，每当有请求的时候，就分配一个线程去工作， 如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃
            - java中的有哪些线程池？1.newCachedThreadPool创建一个可缓存线程池程；2.newFixedThreadPool 创建一个定长线程池；3.newScheduledThreadPool 创建一个定长线程池；4.newSingleThreadExecutor 创建一个单线程化的线程池
        - 栈上的空间什么时候分配的
        - 实现分布式锁
        - 聊聊ZK和Consul
        - ZK的实现，他是用来干嘛的
        - 你们部门的业务处于公司怎样的一个环节
        - 评价下自己，平时有什么爱好
        - 如何做好一件事情
- [java 缓存一致性]
    - 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），如下图所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及 Dragon Protocol等。在本文中将会多次提到的“内存模型”一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而Java虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问操作具有很高的可比性。
    - 除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。

- [史上最全阿里面试题](https://zhuanlan.zhihu.com/p/46144296)
- [知名公司的java面试题](https://www.techug.com/post/java-volatile-keyword.html)
- JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。
- [经典的133个问题列表]()
- [乐观锁](https://www.cnblogs.com/Mainz/p/3546347.html)
    - [两种锁的使用场景 和 ](https://juejin.im/post/5b4977ae5188251b146b2fc8)
    从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。
- 请你解释Object若不重写hashCode()的话，hashCode()如何计算出来的？
    - Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。
- 请你解释为什么重写equals还要重写hashcode？
    - 因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的
- 请你介绍一下map的分类和常见的情况
    - java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap.
    - Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。
    - Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。
    - HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。
    - HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。
    - Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。
    - LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。
    在遍历的时候会比HashMap慢.
    - TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。
- final
    - 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
-  请你谈谈关于Synchronized和lock 
    - synchronized是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。
    Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
- 请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？
    - synchronized修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。
- [若对一个类不重写，它的equals()方法是如何比较的？][若对一个类不重写，它的equals()方法是如何比较的？]
- [请解释hashCode()和equals()方法有什么联系？][若对一个类不重写，它的equals()方法是如何比较的？]
- 内存置换算法 FIFO LRU LFU OPT clock
- 缓存系统如何提高命中率
- TCP/IP 三四 滑动窗口协议
- 数据库索引数据结构  哈希，B+树索引，优劣及应用比较，时间复杂度分析
- IO多路复用，五大IO模型，
- 你知道java8的新特性吗，请简单介绍一下
    - Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。
    - Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。



- 


[若对一个类不重写，它的equals()方法是如何比较的？](https://www.nowcoder.com/tutorial/94/965a74a5195b4904a9106aee097a9a3a)
- java buffer机制
- mapreduce
- 进程通信
- gc设计模式
- 面向对象的特征
- final, finally, finalize 的区别
- int 和 Integer 有什么区别
- 重载和重写的区别
- 
- 抽象类和接口有什么区别
- 
- 说说反射的用途及实现
- 
- 说说自定义注解的场景及实现
- 
- HTTP 请求的 GET 与 POST 方式的区别
- 
- session 与 cookie 区别
- 
- session 分布式处理
- 
- JDBC 流程
- 
- MVC 设计思想
- 
- equals 与 == 的区别
- 
- 集合
- List 和 Set 区别
- 
- List 和 Map 区别
- 
- Arraylist 与 LinkedList 区别
- 
- ArrayList 与 Vector 区别
- 
- HashMap 和 Hashtable 的区别
- 
- HashSet 和 HashMap 区别
- 
- HashMap 和 ConcurrentHashMap 的区别
- 
- HashMap 的工作原理及代码实现
- 
- ConcurrentHashMap 的工作原理及代码实现
- 
- 线程
- 创建线程的方式及实现
- 
- sleep() 、join（）、yield（）有什么区别
- 
- 说说 CountDownLatch 原理
- 
- 说说 CyclicBarrier 原理
- 
- 说说 Semaphore 原理
- 
- 说说 Exchanger 原理
- 
- 说说 CountDownLatch 与 CyclicBarrier 区别
- 
- ThreadLocal 原理分析
- 
- 讲讲线程池的实现原理
- 
- 线程池的几种方式
- 
- 线程的生命周期
- 
- 锁机制
- 说说线程安全问题
- 
- volatile 实现原理
- 
- synchronize 实现原理
- 
- synchronized 与 lock 的区别
- 
- CAS 乐观锁
- 
- ABA 问题
- 
- 乐观锁的业务场景及实现方式
- 
- 核心篇
- 数据存储
- MySQL 索引使用的注意事项
- 
- 说说反模式设计
- 
- 说说分库与分表设计
- 
- 分库与分表带来的分布式困境与应对之策
- 
- 说说 SQL 优化之道
- 
- MySQL 遇到的死锁问题
- 
- 存储引擎的 InnoDB 与 MyISAM
- 
- 数据库索引的原理
- 
- 为什么要用 B-tree
- 
- 聚集索引与非聚集索引的区别
- 
- limit 20000 加载很慢怎么解决
- 
- 选择合适的分布式主键方案
- 
- 选择合适的数据存储方案
- 
- ObjectId 规则
- 
- 聊聊 MongoDB 使用场景
- 
- 倒排索引
- 
- 聊聊 ElasticSearch 使用场景
- 
- 缓存使用
- Redis 有哪些类型
- 
- Redis 内部结构
- 
- 聊聊 Redis 使用场景
- 
- Redis 持久化机制
- 
- Redis 如何实现持久化
- 
- Redis 集群方案与实现
- 
- Redis 为什么是单线程的
- 
- 缓存奔溃
- 
- 缓存降级
- 
- 使用缓存的合理性问题
- 
- 消息队列
- 消息队列的使用场景
- 
- 消息的重发补偿解决思路
- 
- 消息的幂等性解决思路
- 
- 消息的堆积解决思路
- 
- 自己如何实现消息队列
- 
- 如何保证消息的有序性
- 
- 框架篇
- Spring
- BeanFactory 和 ApplicationContext 有什么区别
- 
- Spring Bean 的生命周期
- 
- Spring IOC 如何实现
- 
- 说说 Spring AOP
- 
- Spring AOP 实现原理
- 
- 动态代理（cglib 与 JDK）
- 
- Spring 事务实现方式
- 
- Spring 事务底层原理
- 
- 如何自定义注解实现功能
- 
- Spring MVC 运行流程
- 
- Spring MVC 启动流程
- 
- Spring 的单例实现原理
- 
- Spring 框架中用到了哪些设计模式
- 
- Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring - AMQP 等）
- 
- Netty
- 为什么选择 Netty
- 
- 说说业务中，Netty 的使用场景
- 
- 原生的 NIO 在 JDK 1.7 版本存在 epoll bug
- 
- 什么是TCP 粘包/拆包
- 
- TCP粘包/拆包的解决办法
- 
- Netty 线程模型
- 
- 说说 Netty 的零拷贝
- 
- Netty 内部执行流程
- 
- Netty 重连实现
- 
- 微服务篇
- 微服务
- 前后端分离是如何做的
- 
- 微服务哪些框架
- 
- 你怎么理解 RPC 框架
- 
- 说说 RPC 的实现原理
- 
- 说说 Dubbo 的实现原理
- 
- 你怎么理解 RESTful
- 
- 说说如何设计一个良好的 API
- 
- 如何理解 RESTful API 的幂等性
- 
- 如何保证接口的幂等性
- 
- 说说 CAP 定理、 BASE 理论
- 
- 怎么考虑数据一致性问题
- 
- 说说最终一致性的实现方案
- 
- 你怎么看待微服务
- 
- 微服务与 SOA 的区别
- 
- 如何拆分服务
- 
- 微服务如何进行数据库管理
- 
- 如何应对微服务的链式调用异常
- 
- 对于快速追踪与定位问题
- 
- 微服务的安全
- 
- 分布式
- 谈谈业务中使用分布式的场景
- 
- Session 分布式方案
- 
- 分布式锁的场景
- 
- 分布是锁的实现方案
- 
- 分布式事务
- 
- 集群与负载均衡的算法与实现
- 
- 说说分库与分表设计
- 
- 分库与分表带来的分布式困境与应对之策
- 
- 安全&性能
- 安全问题
- 安全要素与 STRIDE 威胁
- 
- 防范常见的 Web 攻击
- 
- 服务端通信安全攻防
- 
- HTTPS 原理剖析
- 
- HTTPS 降级攻击
- 
- 授权与认证
- 
- 基于角色的访问控制
- 
- 基于数据的访问控制
- 
- 性能优化
- 性能指标有哪些
- 
- 如何发现性能瓶颈
- 
- 性能调优的常见手段
- 
- 说说你在项目中如何进行性能调优
- 
- 工程篇
- 需求分析
- 你如何对需求原型进行理解和拆分
- 
- 说说你对功能性需求的理解
- 
- 说说你对非功能性需求的理解
- 
- 你针对产品提出哪些交互和改进意见
- 
- 你如何理解用户痛点
- 
- 设计能力
- 说说你在项目中使用过的 UML 图
- 
- 你如何考虑组件化
- 
- 你如何考虑服务化
- 
- 你如何进行领域建模
- 
- 你如何划分领域边界
- 
- 说说你项目中的领域建模
- 
- 说说概要设计
- 
- 设计模式
- 你项目中有使用哪些设计模式
- 
- 说说常用开源框架中设计模式使用分析
- 
- 说说你对设计原则的理解
- 
- 23种设计模式的设计理念
- 
- 设计模式之间的异同，例如策略模式与状态模式的区别
- 
- 设计模式之间的结合，例如策略模式+简单工厂模式的实践
- 
- 设计模式的性能，例如单例模式哪种性能更好。
- 
- 业务工程
- 你系统中的前后端分离是如何做的
- 
- 说说你的开发流程
- 
- 你和团队是如何沟通的
- 
- 你如何进行代码评审
- 
- 说说你对技术与业务的理解
- 
- 说说你在项目中经常遇到的 Exception
- 
- 说说你在项目中遇到感觉最难Bug，怎么解决的
- 
- 说说你在项目中遇到印象最深困难，怎么解决的
- 
- 你觉得你们项目还有哪些不足的地方
- 
- 你是否遇到过 CPU 100% ，如何排查与解决
- 
- 你是否遇到过 内存 OOM ，如何排查与解决
- 
- 说说你对敏捷开发的实践
- 
- 说说你对开发运维的实践
- 
- 介绍下工作中的一个对自己最有价值的项目，以及在这个过程中的角色
- 
- 软实力
- 说说你的亮点
- 
- 说说你最近在看什么书
- 
- 说说你觉得最有意义的技术书籍
- 
- 工作之余做什么事情
- 
- 说说个人发展方向方面的思考
- 
- 说说你认为的服务端开发工程师应该具备哪些能力
- 
- 说说你认为的架构师是什么样的，架构师主要做什么
- 
- 说说你所理解的技术专家
- 