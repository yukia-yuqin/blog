---
layout: post
title: java总结
tags: interview java
categories: interview
---

来杯咖啡吧~~<br>
<br>

###真题
- 阿里真题
    - 4、面试内容
    - 考察内容会相对偏基础，给大家一个参考范围（不限于以下内容）：1）基础知识
    - 算法与数据结构（可能有在线编程1-2道，难度是 easy middle 之间）：排序算法，简单的二叉树，大数相关
    - 操作系统与网络：多线程与多进程，内存分页，磁盘管理，死锁及如何避免，http(s)协议的安全性，tcp三次握手与可靠传输
    - 数据库：乐观锁与悲观锁，数据库索引的底层数据结构，数据库的原子性
    - 2）编程语言（Java为例）：HashMap扩容、一致性hash，ConcurrentHashMap，GC原理，Integer与int差别，设计模型（单例、工厂等），NIO等
    - 3）项目经验：描述清楚项目背景，项目的实现与技术难点，自己在项目中的贡献，上述也适用于论文
    - 4）开放题：一般在最后两轮面试会有，主要考察理解能力和反应能力
    - 二面也是技术面，对简历里面的项目再总结一下哈，可以说清楚项目的意义、如何做、碰到的问题与解决方法；再就是一些基础相关的，可以理解原理并思考原因
    - 多进程与多线程
        - 
    - https
        - ssh https://blog.csdn.net/liubo2012/article/details/8894143
        - 先说结论，在【加密】这种场景下，公钥用来加密，私钥用来解密。
        - 公钥的英文是public key，所以可以被别人知道，Bob用Alice的公钥对消息进行加密，并把加密之后的消息传回给Alice；私钥的英文是private key，Alice应该保存好与这个公钥相对应的私钥，不能被别人知道，当Alice收到Bob发来的加密过的消息后，通过手里的私钥对其进行解密。只有私钥可以解密，而公钥不可以，所以即使公钥被窃听者Eve知道也没有关系。
        - 好的，在理解了上述过程之后，我们来说说【签名】这个场景。签名是对上述过程的反向应用，即在此场景下，用私钥进行“加密”，而公钥进行“解密”，这种说法是使题主头晕的原因，所以更清晰的说法是：在此场景下，用私钥进行“签名”，用公钥进行“认证”。因为私钥只有Alice自己知道，所以用私钥对消息进行签名后，只有与之对应的公钥才能对这个签过名的消息进行认证，而公钥又是任何人都可以获取的，所以通过这个过程可以知道该消息确实是属于Alice的。
    - 一致性hash
        - 就是说，”一致性哈希，就是提供一个hashtable,它能在节点加入离开时不会导致映射关系的重大变化“
        - 分布式一致性hash。如果Server的哈希等于Key的哈希，则把Key存放在该Server上；否则，寻找第一个大于Key哈希的Server，用于存放Key。但有Server增加、删除时，只要变动周边的Server映射关系即可，不用全部重新哈希。之所以有这样优良的特性是因为，Server和Key采用了同样的值域。还有最后一个问题，虚节点是如何产生的呢？也非常简单，就是在每个Server加个后缀，在做MD5哈希，取其32位。
    - MD5哈希
        - MD5的结果为一个160bit的数字，取其前32位作为一个Integer
    - hashmap
        -  当使用HashMap时，key被均匀地映射到数组之上，映射方法就是利用key的hash与数组长度取模(通过&运算)。  当put的数据超过负载因子loadFactor×2Len时，HashMap会按照2被的容量扩容。新put进来的数据会通过与新数组的长度取模的方式进行映射。那之前已经映射的数据该怎么办？通过查看HashMap代码的resize方法会发现，每次扩容都会把之前的key重新映射。  所以对HashMap而言要想获得较好的性能必须要提前估计所放数据集合的大小，以设计合适的初始化容量和负载因子。

    - cms停顿了几次？为什么要有这些停顿？ https://zhuanlan.zhihu.com/p/42934904
        - CMS并非没有暂停，而是用两次短暂停来替代串行标记整理算法的长暂停，它的收集周期是这样：初始标记(CMS-initial-mark) -> 并发标记(CMS-concurrent-mark) -> 重新标记(CMS-remark) -> 并发清除(CMS-concurrent-sweep) ->并发重设状态等待下次CMS的触发(CMS-concurrent-reset)。其中的1，3两个步骤需要暂停所有的应用程序线程的。第一次暂停从root对象开始标记存活的对象，这个阶段称为初始标记；第二次暂停是在并发标记之后， 暂停所有应用程序线程，重新标记并发标记阶段遗漏的对象（在并发标记阶段结束后对象状态的更新导致）。第一次暂停会比较短，第二次暂停通常会比较长，并且 remark这个阶段可以并行标记。

    - https加密 https://www.jianshu.com/p/b894a7e1c779
        - 如果和你建立安全连接的人带着这些人的签名，那么认为这个安全连接是安全的，没有遭到中间人攻击。通过 对称加密 + 非对称加密 + CA认证 这三个技术混合在一起，才使得 HTTP 的后面加上了一个 S —— Security。实际上 HTTPS 的协议比我这里描述的更复杂一些，我这里说的主要是基本的实现原理。因为其中任何一环稍有闪失，就会使得整个加密都将变得不安全。这也是为什么 HTTPS 的加密协议从SSL 1.0 升级到 SSL 3.0 再被 TLS 1.0 现在被 TLS 1.2 取代，其背后都是一环环细节上的修改，以防任何地方的闪失。这是因为 非对称加密 的密码对生成和加密的消耗时间比较长，为了节省双方的计算时间，通常只用它来交换密钥，而非直接用来传输数据。


    - java类加载器有哪些
        -Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个（https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html）
            - 基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例。下面详细介绍这个 Java 类。表 1. ClassLoader 中与加载类相关的方法:getParent();loadClass(String name);findClass(String name);findLoadedClass(String name);defineClass(String name, byte[] b, int off, int len);resolveClass(Class<?> c)	
            -  方法 loadClass()抛出的是 java.lang.ClassNotFoundException异常；方法 defineClass()抛出的是 java.lang.NoClassDefFoundError异常。
            - 启动（Bootstrap）类加载器  扩展（Extension）类加载器  系统（System）类加载器
            - 代理模式:双亲委派模型的工作过程如下：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围内没找到这个类）时，自加载器才会尝试自己加载。
            - 代理模式:双亲委派模型是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过双亲委派模型，对于 Java 核心库的类的加载工作由启动类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。
            - Class.forName是一个静态方法，同样可以用来加载类。该方法有两种形式：Class.forName(String name, boolean initialize, ClassLoader loader)和 Class.forName(String className)。第一种形式的参数 name表示的是类的全名；initialize表示是否初始化类；loader表示加载时使用的类加载器。第二种形式则相当于设置了参数 initialize的值为 true，loader的值为当前类的类加载器。
            - 
    - java反射机制及应用
        - 反射则是一开始并不知道我要的类对象是什么，自然也无法使用 new 关键字来创建对象了。反射就是在运行时才知道要初始化/操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。
        - 获取反射中的Class对象
            - 第一种，使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。 Class.forName("类的路径").
            - 第二种，使用 .class 方法。类名.class；
            - 第三种，使用类对象的 getClass() 方法。实例.getClass()。
        - 通过反射创建类对象   Class 对象的 newInstance() 方法   Constructor 对象的 newInstance() 方法
        - 反射的功能：通过反射获取类属性、成员变量和方法、构造器，在运行时创建对象，在运行时调用对象的方法
            - getFields() 方法 ;  getDeclaredFields() 
    - synchronized 底层实现，4种锁。https://blog.csdn.net/javazejian/article/details/72828483
        - 为什么会有线程安全问题：一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据。当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行，这种方式叫互斥锁，当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。在 Java 中，关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到synchronized另外一个重要的作用，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能），这点确实也是很重要的。
        - synchronized底层语义原理：Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的。对于顶部，则是Java头对象，它实现synchronized的锁对象的基础。synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度。其中Mark Word在默认情况下存储着对象的HashCode、分代年龄、锁标记位等以下是32位JVM的Mark Word默认存储结构


        - Java中提供了两种实现同步的基础语义：synchronized方法和synchronized块
        - 重量级锁  重量级锁是我们常说的传统意义上的锁，其利用操作系统底层的同步机制去实现Java中的线程同步。synchronized的对象锁，锁标识位为10，每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的
            - synchronized代码块底层原理。字节码中可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。
            - synchronized方法底层原理。方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。同时我们还必须注意到的是在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了，Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，
        - 锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。
        - 偏向锁
            - 偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。
        - 轻量级锁
            - 倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。
        - 自旋锁
            - 虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。
        - 锁消除
        - synchronized的可重入性
            - 从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性
    
    - FullGC,MinorGC https://youzhixueyuan.com/the-difference-between-minor-gc-major-gc-full-gc.html
        - 年轻代是所有新对象产生的地方。当年轻代内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫做Minor GC。年轻代被分为3个部分——Enden区和两个Survivor区。
        - Minor GC和Major GC其实就是年轻代GC和年老年GC的俗称。而在Hotspot VM具体实现的收集器：Serial GC, Parallel GC, CMS, G1 GC中，大致可以对应到某个Young GC和Old GC算法组合。
        - 当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区。
        - Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区。
        - 经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。
        - Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。永远有一个survivor space是空的，另一个非空的survivor space无碎片。
        - Full GC定义是相对明确的，就是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC。
        - 下图中的Perm代表的是永久代，但是注意永久代并不属于堆内存中的一部分，同时jdk1.8之后永久代已经被移除。
        - 方法区也称”永久代“，它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。
        -  -Xms设置堆的最小空间大小。
        -  -Xmx设置堆的最大空间大小。
        -  -Xmn:设置年轻代大小。
        -  -XX:NewSize设置新生代最小空间大小。
        -  -XX:MaxNewSize设置新生代最大空间大小。
        -  -XX:PermSize设置永久代最小空间大小。
        -  -XX:MaxPermSize设置永久代最大空间大小。
        -  -Xss设置每个线程的堆栈大小。
        -  -XX:+UseParallelGC:选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集。
        -  -XX:ParallelGCThreads=20:配置并行收集器的线程数,即:同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等
        - 深入详解JVM内存模型与JVM参数详细配置  https://youzhixueyuan.com/jvm-memory-model-and-parameter-configuration.html
        - 垃圾回收算法：1.标记清除 https://youzhixueyuan.com/jvm-garbage-collection-algorithm.html
        - 4.分代收集算法。分代收集算法就是目前虚拟机使用的回收算法，它解决了标记整理不适用于老年代的问题，将内存分为各个年代。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法。 
        - 1.新生代的收集器包括：Serial/PraNew/Parallel Scavenge。 https://youzhixueyuan.com/jvm-garbage-collector.html
        - 2.老年代的收集器包括：Serial Old/Parallel Old/CMS
        - 3.回收整个Java堆(新生代和老年代)：G1收集器
        - jvm调优过程
            - https://youzhixueyuan.com/jvm-performance-optimization.html

    - redis主从复制
        - redis: https://segmentfault.com/a/1190000017339258
        - 主从复制是为了数据备份
        - Redis是一个Key-Value存储系统，它支持存储的value类型很多，包括string、list（链表）、set（集合）、zset（有序集合）。这些数据类型都支持push/pop、add/remove以及取交集和并集等丰富的操
        - hash：通过 key(用户ID) + field(属性标签) 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题。很好的解决了问题。
        - list：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。
        - set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。
        - Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。
    - thrift RPC原理
    - Cookie和session的区别
        - cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。
        - 和session的区别是：cookie数据保存在客户端，session数据保存在服务器端。
        - Cookie：
        - 1.Cookie是将会话状态保存在浏览器的技术；
        - 2.Cookie中的数据保存时间较长(可调)；
        - 3.Cookie数据的安全性和稳定性较差(原因是数据保存在用户手中，用户可进行任意修改，病毒可轻易攻击)；
        - 4.Cookie的大小有限制，大小约为4kb。
        - Session
        - 1.Session是将会话状态保存在服务器的技术；
        - 2.Session中的数据保存时间较短，约为30分钟(可调)；
        - 3.Session数据的安全性和稳定性较高(服务器的安全性高，数据存在服务器上安全性高)；
        - 4.Session的大小无限制，理论上可无限大(Session是存在服务器的内存中的，当Session的大小超出内存可承受范- 围，就会自动存储到服务器的硬盘中)
    - 如果登陆了如何其他服务器知道
    - SSO原理，应用场景
        - 单点登录SSO（Single Sign On）说得简单点就是在一个多系统共存的环境下，用户在一处登录后，就不用在其他系统中登录，也就是用户的一次登录能得到其他所有系统的信任。
        - 分布式session方式实现单点登录
            - 例如阿里有很多系统分割为多个子系统，独立部署后，不可避免的会遇到会话管理的问题，类似这样的电商网站一般采用分布式Session实现。再进一步可以根据分布式Session，建立完善的单点登录或账户管理系统。
    - springboot 和 springmvc 和 spring 区别
    - 缓存一致性
    - arryalist和linkedlist的区别
        - 1. ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构；
        - 2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；
        - 3. 对于添加和删除操作add和remove，一般大家都会说LinkedList要比ArrayList快，因为ArrayList要移动数据。但是实际情况并非这样，对于添加或删除，LinkedList和ArrayList并不能明确说明谁快谁慢，下面会详细分析。
    - 公平锁原理
        - 公平锁在锁释放后会严格按照等到队列去取后续值，而非公平锁在对于新晋线程有很大优势。
    - 联合索引
        - 两个或更多个列上的索引被称作联合索引，联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。
    - concurrentHashMap实现原理 全部锁住的情况
    - 红黑树的规则
        - 节点是红色或黑色;根是黑色;所有叶子都是黑色（叶子是NIL节点）;每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）;从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
    - AQS 结合 公平锁
        - AQS底层机制.对java并发机制熟悉的人都知道底层基本上都是基于AQS实现的,即AbstractQueuedSynchronizer.而且AQS里面又维护了一个队列,可以实现线程排队机制,也可以做等待唤醒操作。那到底公平锁和非公平锁的区别在哪？仔细看一下,NonfairSync中的lock方法首先会通过CAS修改state,而FairSync则直接通过acquire获取。因为acquire最终还是通过CAS修改state,只是里面内置了排队机制.而非公平锁则直接修改state的值,无需排队。
    - hashmap扩容
    - 反问
        - 公司技术栈
    - LVS负载均衡怎么支持高并发，负载均衡发生在网络的哪一层
        - LVS是四层负载均衡，也就是说建立在OSI模型的第四层——传输层之上，传输层上有我们熟悉的TCP/UDP，LVS支持TCP/UDP的负载均衡。
    - 讲一下OSI7层模型，传输层是干什么的
        - https://blog.csdn.net/u011774517/article/details/67631439
    - 讲一下URL之后发生了什么
        - 1.DNS域名解析；2.建立TCP连接；3.发送HTTP请求；4.服务器处理请求；5.返回响应结果；6.关闭TCP连接；7.浏览器解析HTML；8.浏览器布局渲染；
    - 讲一下TCP和UDP的区别
        - 1.基于连接与无连接； 
        - 2.对系统资源的要求（TCP较多，UDP少）； 
        - 3.UDP程序结构较简单； 
        - 4.流模式与数据报模式 ；
        - 5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。
    - TCP是如何实现可靠传输的
        - TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。
    - DNS用的什么协议
        - DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议； 
            - DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 
            - 为什么既使用TCP又使用UDP？ 
                首先了解一下TCP与UDP传送字节的长度限制： 
                UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。 
            - 区域传送时使用TCP，主要有一下两点考虑： 
                1.辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 
                2.TCP是一种可靠的连接，保证了数据的准确性。 
            - 域名解析时使用UDP协议： 
                客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。
    - 数据库索引B树和B+树有什么区别，B+树的高度何时发生改变
        - 卫星数据：指的是索引元素所指向的数据记录。比如数据库中的某一行。B树中无论中间节点还是叶子节点都带有卫星数据。B+树中，只有叶子节点带卫星数据，其他中间节点仅仅是索引，没有数据关联。
        - 综合起来，B+树比B-树优势有三个：1、IO次数更少2、查询性能稳定3、范围查询简便。
    - 创建索引的过程
    - Like查询的过程
    - hashmap hash函数，讲一下hashmap size是怎么获取的，是线程安全的吗
        - 大家都知道上面代码里的key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值。“扰动函数”的价值就体现出来了，说到这里大家应该猜出来了。看下面这个图，
        - 其实简单，我们只要调用Object对象的hashCode()方法，该方法会返回一个整数，然后用这个数对HashMap或者HashTable的容量进行取模就行了。没错，其实基本原理就是这个，只不过，在具体实现上，由两个方法int hash(Object k)和int indexFor(int h, int length)来实现。但是考虑到效率等问题，HashMap的实现会稍微复杂一点。hash ：该方法主要是将Object转换成一个整型。indexFor ：该方法主要是将hash生成的整型转换成链表数组中的下标。indexFor方法其实主要是将hash生成的整型转换成链表数组中的下标。那么return h & (length-1);是什么意思呢？其实，他就是取模。Java之所有使用位运算(&)来代替取模运算(%)，最主要的考虑就是效率。位运算(&)效率要比代替取模运算(%)高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。
        - 这段代码是为了对key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。简单点说，就是为了把高位的特征和低位的特征组合起来，降低哈希冲突的概率，也就是说，尽量做到任何一位的变化都能对最终得到的结果产生影响。
        - 我们可以发现，为了保证哈希的结果可以分散、为了提高哈希的效率，JDK在一个小小的hash方法上就有很多考虑，做了很多事情。当然，我希望我们不仅可以深入了解背后的原理，还要学会这种对代码精益求精的态度。
    - 如何用最短时间复杂度内找到一颗二叉树内距离最远的两个节点。
    - 一个数组如何创建一棵平衡二叉树
        - 二分：用有序数组中中间的数生成搜索二叉树的头节点，然后对数组的左右部分分别生成左右子树即可（重复过程）。生成的二叉树中序遍历一定还是这个序列。
- 百度真题
    - 面项目数据库，全程怼数据库（数据库索引优化，联合索引，如何建立索引，数据分裤分表，种类使用场景，如何对数据进行分裤有哪些方式）。面项目数据库（写出数据的表结构表中的字段，表之间的关联，用ER图画，不会，忘了。他说没关系，现在让你设计这个数据库表结构你会如何设计，设计完后，他说需求我写sql语句。我写的比较low，他们会不会数据库连接，左连接，右连接，全链接等）

### 技术面问题

- 面试题
    - 阿里一面（一个小时左右）
        - 排序算法
        - 简单二叉树
        - 大数相关
        - 实现接口与继承类的区别
            - 一个类只能继承一个类，但是可以实现多个接口。接口里面的方法都是抽象方法，必须要重写所有的方法。接口抽象的方法都要被重写，而继承的类不必这样。继承一般开发中用的会相比少一点,接口相比就应该会多一点.，接口主要是实现一种松耦合，便于以后的维护、升级，继承主要是提高代码的可重用性，很多东西都可以在父类中做好。子类可以直接用.
        - Object的方法都有哪些 https://zhb1208.iteye.com/blog/1418324
        - 怎么判断两个对象相等？
            - equals通常用来比较两个对象的内容是否相等，==用来比较两个对象的地址是否相等。Object类中的equals方法定义为判断两个对象的地址是否相等（可以理解成是否是同一个对象），地址相等则认为是对象相等。这也就意味着，我们新建的所有类如果没有复写equals方法，那么判断两个对象是否相等时就等同于“==”，也就是两个对象的地址是否相等。1、类未复写equals方法，则使用equals方法比较两个对象时，相当于==比较，即两个对象的地址是否相等。地址相等，返回true，地址不相等，返回false.2、类复写equals方法，比较两个对象时，则走复写之后的判断方式。通常，我们会将equals复写成：当两个对象内容相同时，则equals返回true，内容不同时，返回false。
        - equals和hashCode
            - hashCode的作用及与equals的关系。hashCode的作用是用来获取哈希码，也可以称作散列码。实际返回值为一个int型数据。用于确定对象在哈希表中的位置。Object中有hashcode方法，也就意味着所有的类都有hashCode方法。但是，hashcode只有在创建某个类的散列表的时候才有用，需要根据hashcode值确认对象在散列表中的位置，但在其他情况下没用。
        - hash冲突
        - 一致性哈希
            - 接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如下所示：综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。
        - HashMap的底层模型
            - JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的时数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。相比于之前的版本， JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。
            - 红黑树特点:每个节点非红即黑；根节点总是黑色的；每个叶子节点都是黑色的空节点（NIL节点）；如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）;
            - 红黑树的应用：TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树。
            - 为什么要用红黑树:简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。
            - 红黑树这么优秀,为何不直接使用红黑树得了?
                - 说一下自己对于这个问题的看法：我们知道红黑树属于（自）平衡二叉树，但是为了保持“平衡”是需要付出代价的，红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，这费事啊。你说说我们引入红黑树就是为了查找数据快，如果链表长度很短的话，根本不需要引入红黑树的，你引入之后还要付出代价维持它的平衡。但是链表过长就不一样了。至于为什么选 8 这个值呢？通过概率统计所得，这个值是综合查询成本和新增元素成本得出的最好的一个值。
            - HashSet 和 HashMap 区别:如果你看过 HashSet 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的
            - HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。
        - ConcurrentHashMap
            - ConcurrentHashMap 和 Hashtable 的区别
            - ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。
            - 底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；
            - 实现线程安全的方式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁)：使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。
        - 刚才提到了segment继承于ReetrantLock，那谈谈Synchronized和Lock的区别
        - CAS https://zl198751.iteye.com/blog/1848575
            - CAS:CAS:Compare and Swap, 翻译成比较并交换。 java.util.concurrent包中借助CAS实现了区别于synchronouse同步锁的一种乐观锁。而compareAndSwapInt就是借助C来调用CPU底层指令实现的。
            - CAS缺点:ABA问题.循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。只能保证一个共享变量的原子操作。
        - 死锁举例
            - 第一种synchronized方式死锁：线程thread1先获取锁locka，然后在同步块里嵌套竞争锁lockb。而线程thread2先获取锁lockb，然后在同步块里嵌套竞争锁locka
            - 第二种concurrent包Lock错误使用，导致死锁：java两种经典死锁例子，Lock发生死锁案列.
        - JVM类加载机制
        - tcp三次握手四次挥手为什么切换进程消耗小
        - mysql引擎 B+树
        - MyISAM和InnoDB区别
        - Java final volatile 关键字 volatile指令重排序 举个重排序例子
            - 相对于synchronized块的代码锁，volatile应该是提供了一个轻量级的针对共享变量的锁，当我们在多个线程间使用共享变量进行通信的时候需要考虑将共享变量用volatile来修饰。
        - JVM对Java做了什么 堆和栈 垃圾回收算法
        - 网络 打开网页 怎么用拥塞控制 路由寻路 TCP UDP区别
        - 数据结构 树的变种 b+和红黑树
        - 操作系统 线程和进程 为什么切换线程消耗小 什么时候进程什么时候线程 虚拟内存 页式存储
            - google的： 进程切换比线程切换开销大是因为进程切换时要切页表，而且往往伴随着页调度，因为进程的数据段代码段要换出去，以便把将要执行的进程的内容换进来。本来进程的内容就是线程的超集。而且线程只需要保存线程的上下文（相关寄存器状态和栈的信息）就好了，动作很小
        - 数据库 事务 隔离级别
            - 在说分布式事务之前，我们先从数据库事务说起。 数据库事务可能大家都很熟悉，在开发过程中也会经常使用到。但是即使如此，可能对于一些细节问题，很多人仍然不清楚。比如很多人都知道数据库事务的几个特性：原子性(Atomicity )、一致性( Consistency )、隔离性或独立性( Isolation)和持久性(Durabilily)，简称就是ACID。但是再往下比如问到隔离性指的是什么的时候可能就不知道了，或者是知道隔离性是什么但是再问到数据库实现隔离的都有哪些级别，或者是每个级别他们有什么区别的时候可能就不知道了
        - 什么是分布式事务 怎么做 https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html
            - CAP定理 一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效)；可用性(Availability) ： 每个操作都必须以可预期的响应结束。分区容错性(Partition tolerance) ： 即使出现单个组件无法可用,操作依然可以完成。具体地讲在分布式系统中，在任何数据库设计中，一个Web应用至多只能同时支持上面的两个属性。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在一致性与可用性之间做出选择。
            - 其中，XA 是一个两阶段提交协议，该协议分为以下两个阶段：
            - 第一阶段：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.
            - 第二阶段：事务协调器要求每个数据库提交数据。
            - BASE理论；Basically Available（基本可用）；Soft state（软状态）；Eventually consistent（最终一致性）
        - 分布式锁
            - 2.1为何需要分布式锁。效率 https://juejin.im/post/5bbb0d8df265da0abd3533a5
            - 5.1Redis分布式锁简单实现
        - 场景题 额度调整不加锁
        - spring ioc aop springboot差别
        - 分布式理解 心得
        - paxos和raft
        - 有什么想问我
        - [https](https://my.oschina.net/u/1778933/blog/421775)
    - 阿里二面
        - 了解设计模式吗？
        - HTTP协议和IP协议
            - TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”
        - GC是如何做到的
        - JavaNIO和IO区别，如果分别用他们实现QQ有什么区别
            - NIO是为了弥补IO操作的不足而诞生的，NIO的一些新特性有：非阻塞I/O，选择器，缓冲以及管道。管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征。1,IO是面向流的，NIO是面向块（缓冲区）的。2，IO是阻塞的，NIO是非阻塞的。
        - HashMap线程安全吗，多线程什么问题
        - ArrayList多线程什么问题
        - 线程池知道吗？为什么用线程池，有什么好处 https://blog.csdn.net/qq_33453910/article/details/81413285
            - 不使用线程池的话，所创建的线程数无法控制，比如一下子创建了几百几千个线程，电脑一下子就崩溃了。1:提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。2:方便管理 可以编写线程池管理代码对池中的线程统一进行管理，比如说系统启动时由该程序创建100个线程，每当有请求的时候，就分配一个线程去工作， 如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃
            - java中的有哪些线程池？1.newCachedThreadPool创建一个可缓存线程池程；2.newFixedThreadPool 创建一个定长线程池；3.newScheduledThreadPool 创建一个定长线程池；4.newSingleThreadExecutor 创建一个单线程化的线程池
        - 栈上的空间什么时候分配的
        - 实现分布式锁
        - 聊聊ZK和Consul
        - ZK的实现，他是用来干嘛的
        - 你们部门的业务处于公司怎样的一个环节
        - 评价下自己，平时有什么爱好
        - 如何做好一件事情
        - 如何设计一个秒杀系统 https://youzhixueyuan.com/how-to-design-double-11-seconds-kill-system.html
            - 比如：利用消息中间件和缓存实现简单的秒杀系统

- 哈希索引
    - 哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。
    - 从上面的图来看，B+树索引和哈希索引的明显区别是：
    1).如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；2).从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；3).同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；4).哈希索引也不支持多列联合索引的最左匹配规则；5).B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。
- 请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？
    - StringBuffer线程安全，StringBuilder线程不安全，底层实现上的话，StringBuffer其实就是比StringBuilder多了Synchronized修饰符。
- 方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。
- 请列举你所知道的Object类的方法并简要说明。
    - Object()默认构造方法。clone() 创建并返回此对象的一个副本。equals(Object obj) 指示某个其他对象是否与此对象“相等”。finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。getClass()返回一个对象的运行时类。hashCode()返回该对象的哈希码值。 notify()唤醒在此对象监视器上等待的单个线程。 notifyAll()唤醒在此对象监视器上等待的所有线程。toString()返回该对象的字符串表示。wait()导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。wait(long timeout)导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。
- 请你说明concurrenthashmap有什么优势以及1.7和1.8区别？
    - Concurrenthashmap线程安全的，1.7是在jdk1.7中采用Segment + HashEntry的方式进行实现的，lock加在Segment上面。1.7size计算是先采用不加锁的方式，连续计算元素的个数，最多计算3次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果前后两次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数；
    - 1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount，通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数；
- 阐述ArrayList、Vector、LinkedList的存储性能和特性
    - ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。
- 讲一下java虚拟机
    - hotspot
- string buffer为什么时线程安全的。https://www.zhihu.com/question/20101840
    - 所以，对于题主的问题，他们的适用场景是什么?最简单的回答是，stringbuffer基本没有适用场景，你应该在所有的情况下选择使用stringbuiler，除非你真的遇到了一个需要线程安全的场景，如果遇到了，请务必在这里留言通知我。
    - 最后，为什么会有stringbuffer的存在，如果真的没有价值，为什么jdk会提供这个类？答案太简单了，因为最早是没有stringbuilder的，sun的人不知处于何种愚蠢的考虑，决定让stringbuffer是线程安全的，然后大约10年之后，人们终于意识到这是一个多么愚蠢的决定，意识到在这10年之中这个愚蠢的决定为java运行速度慢这样的流言贡献了多大的力量，于是，在jdk1.5的时候，终于决定提供一个非线程安全的stringbuffer实现，并命名为stringbuilder。顺便，javac好像大概也是从这个版本开始，把所有用加号连接的string运算都隐式的改写成stringbuilder，也就是说，从jdk1.5开始，用加号拼接字符串已经没有任何性能损失了。
- Redis支持哪几种数据类型？
    - 1.string：最基本的数据类型，二进制安全的字符串，最大512M。
    - 2.list：按照添加顺序保持顺序的字符串列表。
    - 3.set：无序的字符串集合，不存在重复的元素。
    - 4.sorted set：已排序的字符串集合。
    - 5.hash：key-value对的一种集合。
- redis哈希槽
    - Redis集群没有使用一致性hash,而是引入了哈希槽的概念，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。Redis集群预分好16384个桶(哈希槽)
- redis异步复制
- restful api
    - https://youzhixueyuan.com/the-difference-between-restful-soap-rpc-soa-and-micro-service.html
    - RESTful的核心就是后端将资源发布为URI，前端通过URI访问资源，并通过HTTP动词表示要对资源进行的操作。
- 微服务
    - （1）RMI实现，利用java.rmi包实现，基于Java远程方法协议(Java Remote Method Protocol)和java的原生序列化。
    - （2）Hessian，是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 基于HTTP协议，采用二进制编解码。
    - （3）thrift是一种可伸缩的跨语言服务的软件框架。thrift允许你定义一个描述文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。
    - （4）dubbo，阿里的RPC框架。
    - （5）还有SpringCloud框架，微服务全家桶。为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。
    微服务在本质上，就是rpc。rpc有基于tcp的，http的，mq的等等。spring cloud是基于spring boot的，spring boot 实现的是http协议的rpc，算是rpc的一个子集。
    - SOA（Service-Oriented Architecture），中文全称：面向服务的架构。
    -    通俗点来讲，SOA提倡将不同应用程序的业务功能封装成“服务”并宿主起来，通常以接口和契约的形式暴露并提供给外界应用访问（通过交换消息），达到不同系统可重用的目的。
    -   SOA是一个组件模型，它能将不同的服务通过定义良好的接口和契约联系起来。服务是SOA的基石。
    - 总之，微服务是SOA发展出来的产物，它是一种比较现代化的细粒度的SOA实现方式。
    - SOA与微服务的区别在于如下几个方面：
    - 微服务相比于SOA更加精细，微服务更多的以独立的进程的方式存在，互相之间并无影响；微服务提供的接口方式更加通用化，例如HTTP RESTful方式，各种终端都可以调用，无关语言、平台限制；微服务更倾向于分布式去中心化的部署方式，在互联网业务场景下更适合。
- 数据库
    - 锁的优化策略：1. 读写分离； 分段加锁；减少锁持有的时间； 多个线程尽量以相同的顺序去获取资源。不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。
    - 索引的底层实现原理和优化。B+树，经过优化的B+树。主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。
    - 优化数据库的方法。选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM。使用连接(JOIN)来代替子查询。适用联合(UNION)来代替手动创建的临时表。事务处理。锁定表、优化事务处理。适用外键，优化锁定表。建立索引。优化查询语句。
    - 简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）。
    - 说说对SQL语句优化有哪些方法？（选择几条）
        - （1）Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。（2）用EXISTS替代IN、用NOT EXISTS替代NOT IN。（3） 避免在索引列上使用计算（4）避免在索引列上使用IS NULL和IS NOT NULL（5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。（6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描（7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描
- java 8 vs java 9 vs java 7
    - 在 Java 8 中，String 内部使用 char 数组存储数据。
    - 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。
    - 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。
    - 从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。
    - 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。
    - Annontation是Java5开始引入的新特征，中文名称叫注解。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。
    - 从 JDK 1.8 开始，在hashmap中，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。
    - JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。
    - [Java8之后的ConcurrentHashMap, 舍弃分段锁,您好 分段锁技术是在java8以前使用的，在java8已经弃用了，更新为synchronized+cas](https://www.wanaright.com/2018/09/30/java10-concurrenthashmap-no-segment-lock/) 
    - java8 新特性
        - Lambda Expressions
        - Pipelines and Streams
        - Date and Time API
        - Default Methods
        - Type Annotations
        - Nashhorn JavaScript Engine
        - Concurrent Accumulators
        - Parallel operations
        - PermGen Error Removed
    - java7 新特性
        - Strings in Switch Statement
        - Type Inference for Generic Instance Creation
        - Multiple Exception Handling
        - Support for Dynamic Languages
        - Try with Resources
        - Java nio Package
        - Binary Literals, Underscore in literals
        - Diamond Syntax
    - 轻量级锁和偏向锁是Java 6 对 synchronized 锁进行优化后新增加的
- 字符串
    -  string 不可变的好处
        - 可以缓存 hash 值
        - String Pool 的需要
        - String 不可变性天生具备线程安全，可以在多个线程中安全地使用。
        - String 不可变，因此是线程安全的;StringBuilder 不是线程安全的;StringBuffer 是线程安全的，内部使用 synchronized 进行同步
    - 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。
- 访问权限
    - Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。
    - 字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。
    - 接口和抽象类
        - 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。
        - 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。
        - 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
        - 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。
- 重写与重载
    - 为了满足里式替换原则，重写有以下三个限制：    
        - 子类方法的访问权限必须大于等于父类方法；
        - 子类方法的返回类型必须是父类方法返回类型或为其子类型。
        - 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。
        - 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。
    - 重载（Overload）
        - 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。
- 基础知识
    - 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
    - toString()默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。
    - clone方法
        - 应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调 用了 clone() 方法，就会抛出 CloneNotSupportedException。
    - clone替代方案
        - 使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。
    - static
        - 静态变量/ 静态方法 /  静态语句块 / 静态内部类
        - 静态内部类不能访问外部类的非静态的变量和方法。
        - 静态导包 import static com.xxx.ClassName.* 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。
        - 初始化顺序 ： 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。
    - 反射
        - 类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName("com.mysql.jdbc.Driver") 这种方式来控制类的加载，该方法会返回一个 Class 对象。
        - 反射的优点：
            - 可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
            - 类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
            - 调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的API 定义，以确保一组测试中有较高的代码覆盖率。
        - 反射的缺点
            - 性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
            - 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
            - 内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。
    - 异常
        - Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：
    - Java的泛型是如何工作的 ? 什么是类型擦除 ?
        - 泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。
    - [10道java泛型题目](https://cloud.tencent.com/developer/article/1033693)
    -　你可以把List<String>传递给一个接受List<Object>参数的方法吗？
        - 不可以。因为List<Object>可以存储任何类型的对象包括String, Integer等等，而List<String>却只能用来存储Strings。　
    - Array中可以用泛型吗?
        - 　　这可能是Java泛型面试题中最简单的一个了，当然前提是你要知道Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。
- java 容器
    - 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。
    - Collection
        - 1. Set
        - TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。
        - HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
        - LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。
        - 2. List
        - ArrayList：基于动态数组实现，支持随机访问。
        - Vector：和 ArrayList 类似，但它是线程安全的。
        - LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。
        - 3. Queue
        - LinkedList：可以用它来实现双向队列。
        - PriorityQueue：基于堆结构实现，可以用它来实现优先队列。
    - Map
        - TreeMap：基于红黑树实现。
        - HashMap：基于哈希表实现。
        - HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全。
        - LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。
    - 迭代器模式
    - 适配器模式
        - java.util.Arrays#asList() 可以把数组类型转换为 List 类型。
    - Vector
        - Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。
        - 可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。 List<String> synList = Collections.synchronizedList(list); 也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。List<String> list = new CopyOnWriteArrayList<>();
            - CopyOnWriteArrayList
                - 读写分离;写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。写操作需要加锁，防止并发写入时导致写入数据丢失。写操作结束之后需要把原始数组指向新的复制数组。
    - HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。
    - 扩容-重新计算桶下标：假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；如果为 1，那么得到的结果为原来的结果 +16。
    - LRU 缓存
        - [以下是使用 LinkedHashMap 实现的一个 LRU 缓存](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%AE%B9%E5%99%A8)
    - WeakHashMap
        - WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收
    - ConcurrentCache
        - ConcurrentCache Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。
        - ConcurrentCache 采取的是分代缓存：
    - 基础线程机制
        - Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。CachedThreadPool：一个任务创建一个线程；     ExecutorService executorService = Executors.newCachedThreadPool();         executorService.execute(new MyRunnable());
        - Daemon
        - yield()
            - 对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。
    - 中断
        - 调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future<?> 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。
    - 五、互斥同步
        - Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。
        - synchronized 
            - 1. 同步一个代码块 .它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。        synchronized (this) {
            - 2. 同步一个方法 public synchronized void func () {
            - 3. 同步一个类     synchronized (SynchronizedExample.class) { 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。
            - 4. 同步一个静态方. 作用于整个类。
        - ReentrantLock
            - ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。
                -     private Lock lock = new ReentrantLock();         lock.lock();             lock.unlock(); // 确保释放锁，从而避免发生死锁。
        - 比较
            - synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。
            - 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。
            - 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行。
            - 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。
            - 一个 ReentrantLock 可以同时绑定多个 Condition 对象。
            - 除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。
    - 线程之间的协作
        - join() 对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。   
        - wait() notify() notifyAll()；它们都属于 Object 的一部分，而不属于 Thread。
        - await() signal() signalAll()
    - 七、J.U.C - AQS
        - CountDownLatch
        - CyclicBarrier。CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。
        - FutureTask
        - BlockingQueue
            - java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度） 优先级队列 ：PriorityBlockingQueue 提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。
        - ForkJoin
    - 十、Java 内存模型
        - 1. 原子性
            - 使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现。
                -     private AtomicInteger cnt = new AtomicInteger()         
                - cnt.incrementAndGet();
            - 除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。
        - 2. 可见性
            - volatile
            - synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
            - final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。
            - 对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。
        - 3. 有序性
            - volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。
            - 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。
        - 先行发生原则
            -  1. 单一线程原则
            - 2. 管程锁定规则
            - 3. volatile 变量规则
            - 4. 线程启动规则
            - 5. 线程加入规则
            - 6. 线程中断规则
        - 线程安全有以下几种实现方式：
            - 不可变
            - 互斥同步
            - 非阻塞同步
                - CAS 乐观并发策略.先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。
                - 2. AtomicInteger。J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。
                - 3. ABA
            - 无同步方案
                - 1. 栈封闭。多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。
                - 2. 线程本地存储（Thread Local Storage）
                - 3. 可重入代码（Reentrant Code）
        - 锁优化，指 JVM 对 synchronized 的优化。
            - 自旋。互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。
            - 锁消除.锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。
            - 锁粗化。上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。
            - 轻量级锁




























- [史上最全阿里面试题](https://zhuanlan.zhihu.com/p/46144296)
- [知名公司的java面试题](https://www.techug.com/post/java-volatile-keyword.html)
- JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。
- [经典的133个问题列表]()
- [乐观锁](https://www.cnblogs.com/Mainz/p/3546347.html)
    - [两种锁的使用场景 和 ](https://juejin.im/post/5b4977ae5188251b146b2fc8)
    从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。
- 请你解释Object若不重写hashCode()的话，hashCode()如何计算出来的？
    - Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。
- 请你解释为什么重写equals还要重写hashcode？
    - 因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的
- 请你介绍一下map的分类和常见的情况
    - java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap.
    - Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。
    - Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。
    - HashMap是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为NULL，允许多条记录的值为NULL。
    - HashMap不支持线程同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致性。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。
    - Hashtable与HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。
    - LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的。
    在遍历的时候会比HashMap慢.
    - TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iterator遍历TreeMap时，得到的记录是排过序的。
- final
    - 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
-  请你谈谈关于Synchronized和lock 
    - synchronized是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。
    Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
- 请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？
    - synchronized修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。
- [若对一个类不重写，它的equals()方法是如何比较的？][若对一个类不重写，它的equals()方法是如何比较的？]
- [请解释hashCode()和equals()方法有什么联系？][若对一个类不重写，它的equals()方法是如何比较的？]
- 内存置换算法 FIFO LRU LFU OPT clock
- 缓存系统如何提高命中率
- TCP/IP 三四 滑动窗口协议
- 数据库索引数据结构  哈希，B+树索引，优劣及应用比较，时间复杂度分析
- IO多路复用，五大IO模型，
- 你知道java8的新特性吗，请简单介绍一下
    - Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。
    - Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。



- 


[若对一个类不重写，它的equals()方法是如何比较的？](https://www.nowcoder.com/tutorial/94/965a74a5195b4904a9106aee097a9a3a)
- java buffer机制
- mapreduce
- 进程通信
- gc设计模式
- 面向对象的特征
- final, finally, finalize 的区别
- int 和 Integer 有什么区别
- 重载和重写的区别
- 
- 抽象类和接口有什么区别
- 
- 说说反射的用途及实现
- 
- 说说自定义注解的场景及实现
- 
- HTTP 请求的 GET 与 POST 方式的区别
- 
- session 与 cookie 区别
- 
- session 分布式处理
- 
- JDBC 流程
- 
- MVC 设计思想
- 
- equals 与 == 的区别
- 
- 集合
- List 和 Set 区别
- 
- List 和 Map 区别
- 
- Arraylist 与 LinkedList 区别
- 
- ArrayList 与 Vector 区别
- 
- HashMap 和 Hashtable 的区别
- 
- HashSet 和 HashMap 区别
- 
- HashMap 和 ConcurrentHashMap 的区别
- 
- HashMap 的工作原理及代码实现
- 
- ConcurrentHashMap 的工作原理及代码实现
- 
- 线程
- 创建线程的方式及实现
- 
- sleep() 、join（）、yield（）有什么区别
- 
- 说说 CountDownLatch 原理
- 
- 说说 CyclicBarrier 原理
- 
- 说说 Semaphore 原理
- 
- 说说 Exchanger 原理
- 
- 说说 CountDownLatch 与 CyclicBarrier 区别
- 
- ThreadLocal 原理分析
- 
- 讲讲线程池的实现原理
- 
- 线程池的几种方式
- 
- 线程的生命周期
- 
- 锁机制
- 说说线程安全问题
- 
- volatile 实现原理
- 
- synchronize 实现原理
- 
- synchronized 与 lock 的区别
- 
- CAS 乐观锁
- 
- ABA 问题
- 
- 乐观锁的业务场景及实现方式
- 
- 核心篇
- 数据存储
- MySQL 索引使用的注意事项
- 
- 说说反模式设计
- 
- 说说分库与分表设计
- 
- 分库与分表带来的分布式困境与应对之策
- 
- 说说 SQL 优化之道
- 
- MySQL 遇到的死锁问题
- 
- 存储引擎的 InnoDB 与 MyISAM
- 
- 数据库索引的原理
- 
- 为什么要用 B-tree
- 
- 聚集索引与非聚集索引的区别
- 
- limit 20000 加载很慢怎么解决
- 
- 选择合适的分布式主键方案
- 
- 选择合适的数据存储方案
- 
- ObjectId 规则
- 
- 聊聊 MongoDB 使用场景
- 
- 倒排索引
- 
- 聊聊 ElasticSearch 使用场景
- 
- 缓存使用
- Redis 有哪些类型
- 
- Redis 内部结构
- 
- 聊聊 Redis 使用场景
- 
- Redis 持久化机制
- 
- Redis 如何实现持久化
- 
- Redis 集群方案与实现
- 
- Redis 为什么是单线程的
- 
- 缓存奔溃
- 
- 缓存降级
- 
- 使用缓存的合理性问题
- 
- 消息队列
- 消息队列的使用场景
- 
- 消息的重发补偿解决思路
- 
- 消息的幂等性解决思路
- 
- 消息的堆积解决思路
- 
- 自己如何实现消息队列
- 
- 如何保证消息的有序性
- 
- 框架篇
- Spring
- BeanFactory 和 ApplicationContext 有什么区别
- 
- Spring Bean 的生命周期
- 
- Spring IOC 如何实现
- 
- 说说 Spring AOP
- 
- Spring AOP 实现原理
- 
- 动态代理（cglib 与 JDK）
- 
- Spring 事务实现方式
- 
- Spring 事务底层原理
- 
- 如何自定义注解实现功能
- 
- Spring MVC 运行流程
- 
- Spring MVC 启动流程
- 
- Spring 的单例实现原理
- 
- Spring 框架中用到了哪些设计模式
- 
- Spring 其他产品（Srping Boot、Spring Cloud、Spring Secuirity、Spring Data、Spring - AMQP 等）
- 
- Netty
- 为什么选择 Netty
- 
- 说说业务中，Netty 的使用场景
- 
- 原生的 NIO 在 JDK 1.7 版本存在 epoll bug
- 
- 什么是TCP 粘包/拆包
- 
- TCP粘包/拆包的解决办法
- 
- Netty 线程模型
- 
- 说说 Netty 的零拷贝
- 
- Netty 内部执行流程
- 
- Netty 重连实现
- 
- 微服务篇
- 微服务
- 前后端分离是如何做的
- 
- 微服务哪些框架
- 
- 你怎么理解 RPC 框架
- 
- 说说 RPC 的实现原理
- 
- 说说 Dubbo 的实现原理
- 
- 你怎么理解 RESTful
- 
- 说说如何设计一个良好的 API
- 
- 如何理解 RESTful API 的幂等性
- 
- 如何保证接口的幂等性
- 
- 说说 CAP 定理、 BASE 理论
- 
- 怎么考虑数据一致性问题
- 
- 说说最终一致性的实现方案
- 
- 你怎么看待微服务
- 
- 微服务与 SOA 的区别
- 
- 如何拆分服务
- 
- 微服务如何进行数据库管理
- 
- 如何应对微服务的链式调用异常
- 
- 对于快速追踪与定位问题
- 
- 微服务的安全
- 
- 分布式
- 谈谈业务中使用分布式的场景
- 
- Session 分布式方案
- 
- 分布式锁的场景
- 
- 分布是锁的实现方案
- 
- 分布式事务
- 
- 集群与负载均衡的算法与实现
- 
- 说说分库与分表设计
- 
- 分库与分表带来的分布式困境与应对之策
- 
- 安全&性能
- 安全问题
- 安全要素与 STRIDE 威胁
- 
- 防范常见的 Web 攻击
- 
- 服务端通信安全攻防
- 
- HTTPS 原理剖析
- 
- HTTPS 降级攻击
- 
- 授权与认证
- 
- 基于角色的访问控制
- 
- 基于数据的访问控制
- 
- 性能优化
- 性能指标有哪些
- 
- 如何发现性能瓶颈
- 
- 性能调优的常见手段
- 
- 说说你在项目中如何进行性能调优
- 
- 工程篇
- 需求分析
- 你如何对需求原型进行理解和拆分
- 
- 说说你对功能性需求的理解
- 
- 说说你对非功能性需求的理解
- 
- 你针对产品提出哪些交互和改进意见
- 
- 你如何理解用户痛点
- 
- 设计能力
- 说说你在项目中使用过的 UML 图
- 
- 你如何考虑组件化
- 
- 你如何考虑服务化
- 
- 你如何进行领域建模
- 
- 你如何划分领域边界
- 
- 说说你项目中的领域建模
- 
- 说说概要设计
- 
- 设计模式
- 你项目中有使用哪些设计模式
- 
- 说说常用开源框架中设计模式使用分析
- 
- 说说你对设计原则的理解
- 
- 23种设计模式的设计理念
- 
- 设计模式之间的异同，例如策略模式与状态模式的区别
- 
- 设计模式之间的结合，例如策略模式+简单工厂模式的实践
- 
- 设计模式的性能，例如单例模式哪种性能更好。
- 
- 业务工程
- 你系统中的前后端分离是如何做的
- 
- 说说你的开发流程
- 
- 你和团队是如何沟通的
- 
- 你如何进行代码评审
- 
- 说说你对技术与业务的理解
- 
- 说说你在项目中经常遇到的 Exception
- 
- 说说你在项目中遇到感觉最难Bug，怎么解决的
- 
- 说说你在项目中遇到印象最深困难，怎么解决的
- 
- 你觉得你们项目还有哪些不足的地方
- 
- 你是否遇到过 CPU 100% ，如何排查与解决
- 
- 你是否遇到过 内存 OOM ，如何排查与解决
- 
- 说说你对敏捷开发的实践
- 
- 说说你对开发运维的实践
- 
- 介绍下工作中的一个对自己最有价值的项目，以及在这个过程中的角色
- 
- 软实力
- 说说你的亮点
- 
- 说说你最近在看什么书
- 
- 说说你觉得最有意义的技术书籍
- 
- 工作之余做什么事情
- 
- 说说个人发展方向方面的思考
- 
- 说说你认为的服务端开发工程师应该具备哪些能力
- 
- 说说你认为的架构师是什么样的，架构师主要做什么
- 
- 说说你所理解的技术专家
- 